__all__ = ['Expressions']
from typing import Tuple, Set, Iterable, List


class Enumerable(Object):
    @overload
    def Aggregate(source: Iterable[TSource], func: Func`3) -> TSource: ...
    @overload
    def Aggregate(source: Iterable[TSource], seed: TAccumulate, func: Func`3) -> TAccumulate: ...
    @overload
    def Aggregate(source: Iterable[TSource], seed: TAccumulate, func: Func`3, resultSelector: Func) -> TResult: ...
    def All(source: Iterable[TSource], predicate: Func) -> bool: ...
    @overload
    def Any(source: Iterable[TSource]) -> bool: ...
    @overload
    def Any(source: Iterable[TSource], predicate: Func) -> bool: ...
    def Append(source: Iterable[TSource], element: TSource) -> Iterable[TSource]: ...
    def AsEnumerable(source: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Average(source: Iterable[int]) -> float: ...
    @overload
    def Average(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Average(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Average(source: Iterable[Decimal]) -> Decimal: ...
    @overload
    def Average(source: Iterable[float]) -> float: ...
    @overload
    def Average(source: Iterable[Single]) -> Single: ...
    @overload
    def Average(source: Iterable[Int64]) -> float: ...
    @overload
    def Average(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Average(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Average(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Single: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Decimal: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Average(source: Iterable[TSource], selector: Func) -> Nullable: ...
    def Cast(source: IEnumerable) -> Iterable[TResult]: ...
    def Concat(first: Iterable[TSource], second: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Contains(source: Iterable[TSource], value: TSource) -> bool: ...
    @overload
    def Contains(source: Iterable[TSource], value: TSource, comparer: IEqualityComparer) -> bool: ...
    @overload
    def Count(source: Iterable[TSource]) -> int: ...
    @overload
    def Count(source: Iterable[TSource], predicate: Func) -> int: ...
    @overload
    def DefaultIfEmpty(source: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def DefaultIfEmpty(source: Iterable[TSource], defaultValue: TSource) -> Iterable[TSource]: ...
    @overload
    def Distinct(source: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Distinct(source: Iterable[TSource], comparer: IEqualityComparer) -> Iterable[TSource]: ...
    def ElementAt(source: Iterable[TSource], index: int) -> TSource: ...
    def ElementAtOrDefault(source: Iterable[TSource], index: int) -> TSource: ...
    def Empty() -> Iterable[TResult]: ...
    @overload
    def Except(first: Iterable[TSource], second: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Except(first: Iterable[TSource], second: Iterable[TSource], comparer: IEqualityComparer) -> Iterable[TSource]: ...
    @overload
    def First(source: Iterable[TSource]) -> TSource: ...
    @overload
    def First(source: Iterable[TSource], predicate: Func) -> TSource: ...
    @overload
    def FirstOrDefault(source: Iterable[TSource]) -> TSource: ...
    @overload
    def FirstOrDefault(source: Iterable[TSource], predicate: Func) -> TSource: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func) -> Iterable[IGrouping]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, comparer: IEqualityComparer) -> Iterable[IGrouping]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, elementSelector: Func) -> Iterable[IGrouping]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, elementSelector: Func, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> Iterable[TResult]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> Iterable[IGrouping]: ...
    @overload
    def GroupBy(source: Iterable[TSource], keySelector: Func, elementSelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> Iterable[TResult]: ...
    @overload
    def GroupJoin(outer: Iterable[TOuter], inner: Iterable[TInner], outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def GroupJoin(outer: Iterable[TOuter], inner: Iterable[TInner], outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> Iterable[TResult]: ...
    @overload
    def Intersect(first: Iterable[TSource], second: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Intersect(first: Iterable[TSource], second: Iterable[TSource], comparer: IEqualityComparer) -> Iterable[TSource]: ...
    @overload
    def Join(outer: Iterable[TOuter], inner: Iterable[TInner], outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def Join(outer: Iterable[TOuter], inner: Iterable[TInner], outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> Iterable[TResult]: ...
    @overload
    def Last(source: Iterable[TSource]) -> TSource: ...
    @overload
    def Last(source: Iterable[TSource], predicate: Func) -> TSource: ...
    @overload
    def LastOrDefault(source: Iterable[TSource]) -> TSource: ...
    @overload
    def LastOrDefault(source: Iterable[TSource], predicate: Func) -> TSource: ...
    @overload
    def LongCount(source: Iterable[TSource]) -> Int64: ...
    @overload
    def LongCount(source: Iterable[TSource], predicate: Func) -> Int64: ...
    @overload
    def Max(source: Iterable[Single]) -> Single: ...
    @overload
    def Max(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Max(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Max(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Max(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Max(source: Iterable[TSource]) -> TSource: ...
    @overload
    def Max(source: Iterable[float]) -> float: ...
    @overload
    def Max(source: Iterable[Int64]) -> Int64: ...
    @overload
    def Max(source: Iterable[int]) -> int: ...
    @overload
    def Max(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Max(source: Iterable[Decimal]) -> Decimal: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Decimal: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> TResult: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Int64: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Single: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> int: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Max(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource]) -> TSource: ...
    @overload
    def Min(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Min(source: Iterable[int]) -> int: ...
    @overload
    def Min(source: Iterable[Int64]) -> Int64: ...
    @overload
    def Min(source: Iterable[Single]) -> Single: ...
    @overload
    def Min(source: Iterable[float]) -> float: ...
    @overload
    def Min(source: Iterable[Decimal]) -> Decimal: ...
    @overload
    def Min(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Min(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Min(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Min(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Decimal: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> TResult: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> int: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Int64: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Single: ...
    @overload
    def Min(source: Iterable[TSource], selector: Func) -> Nullable: ...
    def OfType(source: IEnumerable) -> Iterable[TResult]: ...
    @overload
    def OrderBy(source: Iterable[TSource], keySelector: Func) -> IOrderedEnumerable: ...
    @overload
    def OrderBy(source: Iterable[TSource], keySelector: Func, comparer: IComparer) -> IOrderedEnumerable: ...
    @overload
    def OrderByDescending(source: Iterable[TSource], keySelector: Func) -> IOrderedEnumerable: ...
    @overload
    def OrderByDescending(source: Iterable[TSource], keySelector: Func, comparer: IComparer) -> IOrderedEnumerable: ...
    def Prepend(source: Iterable[TSource], element: TSource) -> Iterable[TSource]: ...
    def Range(start: int, count: int) -> Iterable[int]: ...
    def Repeat(element: TResult, count: int) -> Iterable[TResult]: ...
    def Reverse(source: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Select(source: Iterable[TSource], selector: Func`3) -> Iterable[TResult]: ...
    @overload
    def Select(source: Iterable[TSource], selector: Func) -> Iterable[TResult]: ...
    @overload
    def SelectMany(source: Iterable[TSource], selector: Func`3) -> Iterable[TResult]: ...
    @overload
    def SelectMany(source: Iterable[TSource], selector: Func) -> Iterable[TResult]: ...
    @overload
    def SelectMany(source: Iterable[TSource], collectionSelector: Func, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def SelectMany(source: Iterable[TSource], collectionSelector: Func`3, resultSelector: Func`3) -> Iterable[TResult]: ...
    @overload
    def SequenceEqual(first: Iterable[TSource], second: Iterable[TSource]) -> bool: ...
    @overload
    def SequenceEqual(first: Iterable[TSource], second: Iterable[TSource], comparer: IEqualityComparer) -> bool: ...
    @overload
    def Single(source: Iterable[TSource]) -> TSource: ...
    @overload
    def Single(source: Iterable[TSource], predicate: Func) -> TSource: ...
    @overload
    def SingleOrDefault(source: Iterable[TSource]) -> TSource: ...
    @overload
    def SingleOrDefault(source: Iterable[TSource], predicate: Func) -> TSource: ...
    def Skip(source: Iterable[TSource], count: int) -> Iterable[TSource]: ...
    @overload
    def SkipWhile(source: Iterable[TSource], predicate: Func`3) -> Iterable[TSource]: ...
    @overload
    def SkipWhile(source: Iterable[TSource], predicate: Func) -> Iterable[TSource]: ...
    @overload
    def Sum(source: Iterable[float]) -> float: ...
    @overload
    def Sum(source: Iterable[Decimal]) -> Decimal: ...
    @overload
    def Sum(source: Iterable[Int64]) -> Int64: ...
    @overload
    def Sum(source: Iterable[Single]) -> Single: ...
    @overload
    def Sum(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Sum(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Sum(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Sum(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Sum(source: Iterable[Nullable]) -> Nullable: ...
    @overload
    def Sum(source: Iterable[int]) -> int: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Single: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> float: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Decimal: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Nullable: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> int: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Int64: ...
    @overload
    def Sum(source: Iterable[TSource], selector: Func) -> Nullable: ...
    def Take(source: Iterable[TSource], count: int) -> Iterable[TSource]: ...
    @overload
    def TakeWhile(source: Iterable[TSource], predicate: Func) -> Iterable[TSource]: ...
    @overload
    def TakeWhile(source: Iterable[TSource], predicate: Func`3) -> Iterable[TSource]: ...
    @overload
    def ThenBy(source: IOrderedEnumerable, keySelector: Func) -> IOrderedEnumerable: ...
    @overload
    def ThenBy(source: IOrderedEnumerable, keySelector: Func, comparer: IComparer) -> IOrderedEnumerable: ...
    @overload
    def ThenByDescending(source: IOrderedEnumerable, keySelector: Func) -> IOrderedEnumerable: ...
    @overload
    def ThenByDescending(source: IOrderedEnumerable, keySelector: Func, comparer: IComparer) -> IOrderedEnumerable: ...
    def ToArray(source: Iterable[TSource]) -> Set(TSource): ...
    @overload
    def ToDictionary(source: Iterable[TSource], keySelector: Func) -> Dictionary: ...
    @overload
    def ToDictionary(source: Iterable[TSource], keySelector: Func, comparer: IEqualityComparer) -> Dictionary: ...
    @overload
    def ToDictionary(source: Iterable[TSource], keySelector: Func, elementSelector: Func) -> Dictionary: ...
    @overload
    def ToDictionary(source: Iterable[TSource], keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> Dictionary: ...
    @overload
    def ToHashSet(source: Iterable[TSource]) -> HashSet: ...
    @overload
    def ToHashSet(source: Iterable[TSource], comparer: IEqualityComparer) -> HashSet: ...
    def ToList(source: Iterable[TSource]) -> List: ...
    @overload
    def ToLookup(source: Iterable[TSource], keySelector: Func) -> ILookup: ...
    @overload
    def ToLookup(source: Iterable[TSource], keySelector: Func, comparer: IEqualityComparer) -> ILookup: ...
    @overload
    def ToLookup(source: Iterable[TSource], keySelector: Func, elementSelector: Func) -> ILookup: ...
    @overload
    def ToLookup(source: Iterable[TSource], keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> ILookup: ...
    @overload
    def Union(first: Iterable[TSource], second: Iterable[TSource]) -> Iterable[TSource]: ...
    @overload
    def Union(first: Iterable[TSource], second: Iterable[TSource], comparer: IEqualityComparer) -> Iterable[TSource]: ...
    @overload
    def Where(source: Iterable[TSource], predicate: Func) -> Iterable[TSource]: ...
    @overload
    def Where(source: Iterable[TSource], predicate: Func`3) -> Iterable[TSource]: ...
    def Zip(first: Iterable[TFirst], second: Iterable[TSecond], resultSelector: Func`3) -> Iterable[TResult]: ...


class EnumerableExecutor(Object):
    pass




class EnumerableQuery(Object):
    pass










class IOrderedQueryable:
    pass




class IQueryable:
    @property
    def ElementType(self) -> Type: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def Provider(self) -> IQueryProvider: ...




class IQueryProvider:
    @overload
    def CreateQuery(self, expression: Expression) -> IQueryable: ...
    @overload
    def CreateQuery(self, expression: Expression) -> IQueryable: ...
    @overload
    def Execute(self, expression: Expression) -> Object: ...
    @overload
    def Execute(self, expression: Expression) -> TResult: ...






class ParallelEnumerable(Object):
    @overload
    def Aggregate(source: ParallelQuery, func: Func`3) -> TSource: ...
    @overload
    def Aggregate(source: ParallelQuery, seed: TAccumulate, func: Func`3) -> TAccumulate: ...
    @overload
    def Aggregate(source: ParallelQuery, seed: TAccumulate, func: Func`3, resultSelector: Func) -> TResult: ...
    @overload
    def Aggregate(source: ParallelQuery, seed: TAccumulate, updateAccumulatorFunc: Func`3, combineAccumulatorsFunc: Func`3, resultSelector: Func) -> TResult: ...
    @overload
    def Aggregate(source: ParallelQuery, seedFactory: Func, updateAccumulatorFunc: Func`3, combineAccumulatorsFunc: Func`3, resultSelector: Func) -> TResult: ...
    def All(source: ParallelQuery, predicate: Func) -> bool: ...
    @overload
    def Any(source: ParallelQuery) -> bool: ...
    @overload
    def Any(source: ParallelQuery, predicate: Func) -> bool: ...
    def AsEnumerable(source: ParallelQuery) -> Iterable[TSource]: ...
    @overload
    def AsOrdered(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def AsOrdered(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def AsParallel(source: IEnumerable) -> ParallelQuery: ...
    @overload
    def AsParallel(source: Partitioner) -> ParallelQuery: ...
    @overload
    def AsParallel(source: Iterable[TSource]) -> ParallelQuery: ...
    def AsSequential(source: ParallelQuery) -> Iterable[TSource]: ...
    def AsUnordered(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Average(source: ParallelQuery) -> float: ...
    @overload
    def Average(source: ParallelQuery) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery) -> Decimal: ...
    @overload
    def Average(source: ParallelQuery) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery) -> Single: ...
    @overload
    def Average(source: ParallelQuery) -> float: ...
    @overload
    def Average(source: ParallelQuery) -> float: ...
    @overload
    def Average(source: ParallelQuery) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> float: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Single: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> float: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> Decimal: ...
    @overload
    def Average(source: ParallelQuery, selector: Func) -> float: ...
    def Cast(source: ParallelQuery) -> ParallelQuery: ...
    def Concat(first: ParallelQuery, second: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Contains(source: ParallelQuery, value: TSource) -> bool: ...
    @overload
    def Contains(source: ParallelQuery, value: TSource, comparer: IEqualityComparer) -> bool: ...
    @overload
    def Count(source: ParallelQuery) -> int: ...
    @overload
    def Count(source: ParallelQuery, predicate: Func) -> int: ...
    @overload
    def DefaultIfEmpty(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def DefaultIfEmpty(source: ParallelQuery, defaultValue: TSource) -> ParallelQuery: ...
    @overload
    def Distinct(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Distinct(source: ParallelQuery, comparer: IEqualityComparer) -> ParallelQuery: ...
    def ElementAt(source: ParallelQuery, index: int) -> TSource: ...
    def ElementAtOrDefault(source: ParallelQuery, index: int) -> TSource: ...
    def Empty() -> ParallelQuery: ...
    @overload
    def Except(first: ParallelQuery, second: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Except(first: ParallelQuery, second: ParallelQuery, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def First(source: ParallelQuery) -> TSource: ...
    @overload
    def First(source: ParallelQuery, predicate: Func) -> TSource: ...
    @overload
    def FirstOrDefault(source: ParallelQuery) -> TSource: ...
    @overload
    def FirstOrDefault(source: ParallelQuery, predicate: Func) -> TSource: ...
    def ForAll(source: ParallelQuery, action: Action) -> None: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, elementSelector: Func) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, elementSelector: Func, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def GroupBy(source: ParallelQuery, keySelector: Func, elementSelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def GroupJoin(outer: ParallelQuery, inner: ParallelQuery, outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def GroupJoin(outer: ParallelQuery, inner: ParallelQuery, outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def Intersect(first: ParallelQuery, second: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Intersect(first: ParallelQuery, second: ParallelQuery, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def Join(outer: ParallelQuery, inner: ParallelQuery, outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def Join(outer: ParallelQuery, inner: ParallelQuery, outerKeySelector: Func, innerKeySelector: Func, resultSelector: Func`3, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def Last(source: ParallelQuery) -> TSource: ...
    @overload
    def Last(source: ParallelQuery, predicate: Func) -> TSource: ...
    @overload
    def LastOrDefault(source: ParallelQuery) -> TSource: ...
    @overload
    def LastOrDefault(source: ParallelQuery, predicate: Func) -> TSource: ...
    @overload
    def LongCount(source: ParallelQuery) -> Int64: ...
    @overload
    def LongCount(source: ParallelQuery, predicate: Func) -> Int64: ...
    @overload
    def Max(source: ParallelQuery) -> TSource: ...
    @overload
    def Max(source: ParallelQuery) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery) -> Decimal: ...
    @overload
    def Max(source: ParallelQuery) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery) -> float: ...
    @overload
    def Max(source: ParallelQuery) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery) -> Single: ...
    @overload
    def Max(source: ParallelQuery) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery) -> Int64: ...
    @overload
    def Max(source: ParallelQuery) -> int: ...
    @overload
    def Max(source: ParallelQuery) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> TResult: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Decimal: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> float: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Single: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Int64: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> int: ...
    @overload
    def Max(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> Decimal: ...
    @overload
    def Min(source: ParallelQuery) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> float: ...
    @overload
    def Min(source: ParallelQuery) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> Int64: ...
    @overload
    def Min(source: ParallelQuery) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery) -> int: ...
    @overload
    def Min(source: ParallelQuery) -> TSource: ...
    @overload
    def Min(source: ParallelQuery) -> Single: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> TResult: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Int64: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Decimal: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Single: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> float: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Min(source: ParallelQuery, selector: Func) -> int: ...
    def OfType(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def OrderBy(source: ParallelQuery, keySelector: Func) -> OrderedParallelQuery: ...
    @overload
    def OrderBy(source: ParallelQuery, keySelector: Func, comparer: IComparer) -> OrderedParallelQuery: ...
    @overload
    def OrderByDescending(source: ParallelQuery, keySelector: Func) -> OrderedParallelQuery: ...
    @overload
    def OrderByDescending(source: ParallelQuery, keySelector: Func, comparer: IComparer) -> OrderedParallelQuery: ...
    def Range(start: int, count: int) -> ParallelQuery: ...
    def Repeat(element: TResult, count: int) -> ParallelQuery: ...
    def Reverse(source: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Select(source: ParallelQuery, selector: Func`3) -> ParallelQuery: ...
    @overload
    def Select(source: ParallelQuery, selector: Func) -> ParallelQuery: ...
    @overload
    def SelectMany(source: ParallelQuery, selector: Func) -> ParallelQuery: ...
    @overload
    def SelectMany(source: ParallelQuery, selector: Func`3) -> ParallelQuery: ...
    @overload
    def SelectMany(source: ParallelQuery, collectionSelector: Func, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def SelectMany(source: ParallelQuery, collectionSelector: Func`3, resultSelector: Func`3) -> ParallelQuery: ...
    @overload
    def SequenceEqual(first: ParallelQuery, second: ParallelQuery) -> bool: ...
    @overload
    def SequenceEqual(first: ParallelQuery, second: ParallelQuery, comparer: IEqualityComparer) -> bool: ...
    @overload
    def Single(source: ParallelQuery) -> TSource: ...
    @overload
    def Single(source: ParallelQuery, predicate: Func) -> TSource: ...
    @overload
    def SingleOrDefault(source: ParallelQuery) -> TSource: ...
    @overload
    def SingleOrDefault(source: ParallelQuery, predicate: Func) -> TSource: ...
    def Skip(source: ParallelQuery, count: int) -> ParallelQuery: ...
    @overload
    def SkipWhile(source: ParallelQuery, predicate: Func`3) -> ParallelQuery: ...
    @overload
    def SkipWhile(source: ParallelQuery, predicate: Func) -> ParallelQuery: ...
    @overload
    def Sum(source: ParallelQuery) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery) -> Decimal: ...
    @overload
    def Sum(source: ParallelQuery) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery) -> Int64: ...
    @overload
    def Sum(source: ParallelQuery) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery) -> Single: ...
    @overload
    def Sum(source: ParallelQuery) -> float: ...
    @overload
    def Sum(source: ParallelQuery) -> int: ...
    @overload
    def Sum(source: ParallelQuery) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Int64: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Single: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> float: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> int: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Nullable: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Decimal: ...
    @overload
    def Sum(source: ParallelQuery, selector: Func) -> Nullable: ...
    def Take(source: ParallelQuery, count: int) -> ParallelQuery: ...
    @overload
    def TakeWhile(source: ParallelQuery, predicate: Func`3) -> ParallelQuery: ...
    @overload
    def TakeWhile(source: ParallelQuery, predicate: Func) -> ParallelQuery: ...
    @overload
    def ThenBy(source: OrderedParallelQuery, keySelector: Func) -> OrderedParallelQuery: ...
    @overload
    def ThenBy(source: OrderedParallelQuery, keySelector: Func, comparer: IComparer) -> OrderedParallelQuery: ...
    @overload
    def ThenByDescending(source: OrderedParallelQuery, keySelector: Func) -> OrderedParallelQuery: ...
    @overload
    def ThenByDescending(source: OrderedParallelQuery, keySelector: Func, comparer: IComparer) -> OrderedParallelQuery: ...
    def ToArray(source: ParallelQuery) -> Set(TSource): ...
    @overload
    def ToDictionary(source: ParallelQuery, keySelector: Func) -> Dictionary: ...
    @overload
    def ToDictionary(source: ParallelQuery, keySelector: Func, elementSelector: Func) -> Dictionary: ...
    @overload
    def ToDictionary(source: ParallelQuery, keySelector: Func, comparer: IEqualityComparer) -> Dictionary: ...
    @overload
    def ToDictionary(source: ParallelQuery, keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> Dictionary: ...
    def ToList(source: ParallelQuery) -> List: ...
    @overload
    def ToLookup(source: ParallelQuery, keySelector: Func) -> ILookup: ...
    @overload
    def ToLookup(source: ParallelQuery, keySelector: Func, comparer: IEqualityComparer) -> ILookup: ...
    @overload
    def ToLookup(source: ParallelQuery, keySelector: Func, elementSelector: Func) -> ILookup: ...
    @overload
    def ToLookup(source: ParallelQuery, keySelector: Func, elementSelector: Func, comparer: IEqualityComparer) -> ILookup: ...
    @overload
    def Union(first: ParallelQuery, second: ParallelQuery) -> ParallelQuery: ...
    @overload
    def Union(first: ParallelQuery, second: ParallelQuery, comparer: IEqualityComparer) -> ParallelQuery: ...
    @overload
    def Where(source: ParallelQuery, predicate: Func`3) -> ParallelQuery: ...
    @overload
    def Where(source: ParallelQuery, predicate: Func) -> ParallelQuery: ...
    def WithCancellation(source: ParallelQuery, cancellationToken: CancellationToken) -> ParallelQuery: ...
    def WithDegreeOfParallelism(source: ParallelQuery, degreeOfParallelism: int) -> ParallelQuery: ...
    def WithExecutionMode(source: ParallelQuery, executionMode: ParallelExecutionMode) -> ParallelQuery: ...
    def WithMergeOptions(source: ParallelQuery, mergeOptions: ParallelMergeOptions) -> ParallelQuery: ...
    def Zip(first: ParallelQuery, second: ParallelQuery, resultSelector: Func`3) -> ParallelQuery: ...


class ParallelExecutionMode:
    Default = 0
    ForceParallelism = 1


class ParallelMergeOptions:
    Default = 0
    NotBuffered = 1
    AutoBuffered = 2
    FullyBuffered = 3


class ParallelQuery(Object):
    pass




class Queryable(Object):
    @overload
    def Aggregate(source: IQueryable, func: Expression) -> TSource: ...
    @overload
    def Aggregate(source: IQueryable, seed: TAccumulate, func: Expression) -> TAccumulate: ...
    @overload
    def Aggregate(source: IQueryable, seed: TAccumulate, func: Expression, selector: Expression) -> TResult: ...
    def All(source: IQueryable, predicate: Expression) -> bool: ...
    @overload
    def Any(source: IQueryable) -> bool: ...
    @overload
    def Any(source: IQueryable, predicate: Expression) -> bool: ...
    @overload
    def AsQueryable(source: IEnumerable) -> IQueryable: ...
    @overload
    def AsQueryable(source: Iterable[TElement]) -> IQueryable: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> Single: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> Decimal: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Single: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Decimal: ...
    def Cast(source: IQueryable) -> IQueryable: ...
    def Concat(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Contains(source: IQueryable, item: TSource) -> bool: ...
    @overload
    def Contains(source: IQueryable, item: TSource, comparer: IEqualityComparer) -> bool: ...
    @overload
    def Count(source: IQueryable) -> int: ...
    @overload
    def Count(source: IQueryable, predicate: Expression) -> int: ...
    @overload
    def DefaultIfEmpty(source: IQueryable) -> IQueryable: ...
    @overload
    def DefaultIfEmpty(source: IQueryable, defaultValue: TSource) -> IQueryable: ...
    @overload
    def Distinct(source: IQueryable) -> IQueryable: ...
    @overload
    def Distinct(source: IQueryable, comparer: IEqualityComparer) -> IQueryable: ...
    def ElementAt(source: IQueryable, index: int) -> TSource: ...
    def ElementAtOrDefault(source: IQueryable, index: int) -> TSource: ...
    @overload
    def Except(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Except(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def First(source: IQueryable) -> TSource: ...
    @overload
    def First(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupJoin(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupJoin(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Intersect(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Intersect(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Join(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def Join(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Last(source: IQueryable) -> TSource: ...
    @overload
    def Last(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def LongCount(source: IQueryable) -> Int64: ...
    @overload
    def LongCount(source: IQueryable, predicate: Expression) -> Int64: ...
    @overload
    def Max(source: IQueryable) -> TSource: ...
    @overload
    def Max(source: IQueryable, selector: Expression) -> TResult: ...
    @overload
    def Min(source: IQueryable) -> TSource: ...
    @overload
    def Min(source: IQueryable, selector: Expression) -> TResult: ...
    def OfType(source: IQueryable) -> IQueryable: ...
    @overload
    def OrderBy(source: IQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def OrderBy(source: IQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def OrderByDescending(source: IQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def OrderByDescending(source: IQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    def Reverse(source: IQueryable) -> IQueryable: ...
    @overload
    def Select(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def Select(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, collectionSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, collectionSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def SequenceEqual(source1: IQueryable, source2: Iterable[TSource]) -> bool: ...
    @overload
    def SequenceEqual(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> bool: ...
    @overload
    def Single(source: IQueryable) -> TSource: ...
    @overload
    def Single(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    def Skip(source: IQueryable, count: int) -> IQueryable: ...
    @overload
    def SkipWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def SkipWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> int: ...
    @overload
    def Sum(source: IQueryable) -> Int64: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Single: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> float: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Decimal: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Single: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> int: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Int64: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Decimal: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    def Take(source: IQueryable, count: int) -> IQueryable: ...
    @overload
    def TakeWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def TakeWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def ThenBy(source: IOrderedQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def ThenBy(source: IOrderedQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def ThenByDescending(source: IOrderedQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def ThenByDescending(source: IOrderedQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def Union(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Union(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Where(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def Where(source: IQueryable, predicate: Expression) -> IQueryable: ...
    def Zip(source1: IQueryable, source2: Iterable[TSecond], resultSelector: Expression) -> IQueryable: ...
