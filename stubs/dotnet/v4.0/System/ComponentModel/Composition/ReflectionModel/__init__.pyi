from typing import Tuple, Set, Iterable, List


class LazyMemberInfo(ValueType):
    @overload
    def __init__(self, member: MemberInfo): ...
    @overload
    def __init__(self, memberType: MemberTypes, accessors: Set(MemberInfo)): ...
    @overload
    def __init__(self, memberType: MemberTypes, accessorsCreator: Func): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def MemberType(self) -> MemberTypes: ...
    def GetAccessors(self) -> Set(MemberInfo): ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: LazyMemberInfo, right: LazyMemberInfo) -> bool: ...
    def op_Inequality(left: LazyMemberInfo, right: LazyMemberInfo) -> bool: ...


class ReflectionModelServices(Object):
    def CreateExportDefinition(exportingMember: LazyMemberInfo, contractName: str, metadata: Lazy, origin: ICompositionElement) -> ExportDefinition: ...
    @overload
    def CreateImportDefinition(parameter: Lazy, contractName: str, requiredTypeIdentity: str, requiredMetadata: Iterable[KeyValuePair], cardinality: ImportCardinality, requiredCreationPolicy: CreationPolicy, origin: ICompositionElement) -> ContractBasedImportDefinition: ...
    @overload
    def CreateImportDefinition(importingMember: LazyMemberInfo, contractName: str, requiredTypeIdentity: str, requiredMetadata: Iterable[KeyValuePair], cardinality: ImportCardinality, isRecomposable: bool, requiredCreationPolicy: CreationPolicy, origin: ICompositionElement) -> ContractBasedImportDefinition: ...
    @overload
    def CreateImportDefinition(parameter: Lazy, contractName: str, requiredTypeIdentity: str, requiredMetadata: Iterable[KeyValuePair], cardinality: ImportCardinality, requiredCreationPolicy: CreationPolicy, metadata: IDictionary, isExportFactory: bool, origin: ICompositionElement) -> ContractBasedImportDefinition: ...
    @overload
    def CreateImportDefinition(importingMember: LazyMemberInfo, contractName: str, requiredTypeIdentity: str, requiredMetadata: Iterable[KeyValuePair], cardinality: ImportCardinality, isRecomposable: bool, requiredCreationPolicy: CreationPolicy, metadata: IDictionary, isExportFactory: bool, origin: ICompositionElement) -> ContractBasedImportDefinition: ...
    @overload
    def CreateImportDefinition(importingMember: LazyMemberInfo, contractName: str, requiredTypeIdentity: str, requiredMetadata: Iterable[KeyValuePair], cardinality: ImportCardinality, isRecomposable: bool, isPreRequisite: bool, requiredCreationPolicy: CreationPolicy, metadata: IDictionary, isExportFactory: bool, origin: ICompositionElement) -> ContractBasedImportDefinition: ...
    def CreatePartDefinition(partType: Lazy, isDisposalRequired: bool, imports: Lazy, exports: Lazy, metadata: Lazy, origin: ICompositionElement) -> ComposablePartDefinition: ...
    def GetExportFactoryProductImportDefinition(importDefinition: ImportDefinition) -> ContractBasedImportDefinition: ...
    def GetExportingMember(exportDefinition: ExportDefinition) -> LazyMemberInfo: ...
    def GetImportingMember(importDefinition: ImportDefinition) -> LazyMemberInfo: ...
    def GetImportingParameter(importDefinition: ImportDefinition) -> Lazy: ...
    def GetPartType(partDefinition: ComposablePartDefinition) -> Lazy: ...
    def IsDisposalRequired(partDefinition: ComposablePartDefinition) -> bool: ...
    def IsExportFactoryImportDefinition(importDefinition: ImportDefinition) -> bool: ...
    def IsImportingParameter(importDefinition: ImportDefinition) -> bool: ...
    def TryMakeGenericPartDefinition(partDefinition: ComposablePartDefinition, genericParameters: Iterable[Type]) -> Tuple[bool, ComposablePartDefinition]: ...
