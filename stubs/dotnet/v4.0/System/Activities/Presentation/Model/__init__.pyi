from typing import Tuple, Set, Iterable, List


class AttachedPropertiesService(Object):
    def __init__(self): ...
    def AddProperty(self, property: AttachedProperty) -> None: ...


class AttachedProperty(Object):
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def OwnerType(self) -> Type: ...
    @property
    def Type(self) -> Type: ...
    def GetValue(self, modelItem: ModelItem) -> Object: ...
    def NotifyPropertyChanged(self, modelItem: ModelItem) -> None: ...
    def ResetValue(self, modelItem: ModelItem) -> None: ...
    @IsBrowsable.setter
    def IsBrowsable(self, value: bool) -> None: ...
    @Name.setter
    def Name(self, value: str) -> None: ...
    @OwnerType.setter
    def OwnerType(self, value: Type) -> None: ...
    def SetValue(self, modelItem: ModelItem, value: Object) -> None: ...




class AttachedPropertyInfo(Object):
    @property
    def PropertyName(self) -> str: ...
    @PropertyName.setter
    def PropertyName(self, value: str) -> None: ...




class Change(Object):
    def Apply(self) -> bool: ...
    @property
    def Description(self) -> str: ...
    def GetInverse(self) -> Change: ...


class CreateOptions:
    #None = 0
    InitializeDefaults = 1


class EditingScope(ModelEditingScope):
    @property
    def Changes(self) -> List: ...
    @property
    def HasEffectiveChanges(self) -> bool: ...


class EditingScopeEventArgs(EventArgs):
    def __init__(self): ...
    @property
    def EditingScope(self) -> EditingScope: ...
    @EditingScope.setter
    def EditingScope(self, value: EditingScope) -> None: ...


class ModelEditingScope(Object):
    def Complete(self) -> None: ...
    def Dispose(self) -> None: ...
    @property
    def Description(self) -> str: ...
    def Revert(self) -> None: ...
    @Description.setter
    def Description(self, value: str) -> None: ...


class ModelFactory(Object):
    @overload
    def CreateItem(context: EditingContext, item: Object) -> ModelItem: ...
    @overload
    def CreateItem(context: EditingContext, itemType: Type, arguments: Set(Object)) -> ModelItem: ...
    @overload
    def CreateItem(context: EditingContext, itemType: Type, options: CreateOptions, arguments: Set(Object)) -> ModelItem: ...
    def CreateStaticMemberItem(context: EditingContext, type: Type, memberName: str) -> ModelItem: ...


class ModelItem(Object):
    def add_PropertyChanged(self, value: PropertyChangedEventHandler) -> None: ...
    @overload
    def BeginEdit(self) -> ModelEditingScope: ...
    @overload
    def BeginEdit(self, shouldApplyChangesImmediately: bool) -> ModelEditingScope: ...
    @overload
    def BeginEdit(self, description: str) -> ModelEditingScope: ...
    @overload
    def BeginEdit(self, description: str, shouldApplyChangesImmediately: bool) -> ModelEditingScope: ...
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Content(self) -> ModelProperty: ...
    @property
    def ItemType(self) -> Type: ...
    @property
    def Name(self) -> str: ...
    @property
    def Parent(self) -> ModelItem: ...
    @property
    def Parents(self) -> Iterable[ModelItem]: ...
    @property
    def Properties(self) -> ModelPropertyCollection: ...
    @property
    def Root(self) -> ModelItem: ...
    @property
    def Source(self) -> ModelProperty: ...
    @property
    def Sources(self) -> Iterable[ModelProperty]: ...
    @property
    def View(self) -> DependencyObject: ...
    def GetCurrentValue(self) -> Object: ...
    def remove_PropertyChanged(self, value: PropertyChangedEventHandler) -> None: ...
    @Name.setter
    def Name(self, value: str) -> None: ...
    def ToString(self) -> str: ...


class ModelItemCollection(ModelItem):
    def add_CollectionChanged(self, value: NotifyCollectionChangedEventHandler) -> None: ...
    @overload
    def Add(self, value: Object) -> ModelItem: ...
    @overload
    def Add(self, item: ModelItem) -> None: ...
    def Clear(self) -> None: ...
    @overload
    def Contains(self, item: ModelItem) -> bool: ...
    @overload
    def Contains(self, value: Object) -> bool: ...
    def CopyTo(self, array: Set(ModelItem), arrayIndex: int) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self, index: int) -> ModelItem: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, item: ModelItem) -> int: ...
    @overload
    def Insert(self, index: int, value: Object) -> ModelItem: ...
    @overload
    def Insert(self, index: int, item: ModelItem) -> None: ...
    def Move(self, fromIndex: int, toIndex: int) -> None: ...
    def remove_CollectionChanged(self, value: NotifyCollectionChangedEventHandler) -> None: ...
    @overload
    def Remove(self, value: Object) -> bool: ...
    @overload
    def Remove(self, item: ModelItem) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    @Item.setter
    def Item(self, index: int, value: ModelItem) -> None: ...


class ModelItemDictionary(ModelItem):
    def add_CollectionChanged(self, value: NotifyCollectionChangedEventHandler) -> None: ...
    @overload
    def Add(self, key: ModelItem, value: ModelItem) -> None: ...
    @overload
    def Add(self, key: Object, value: Object) -> ModelItem: ...
    def Clear(self) -> None: ...
    @overload
    def ContainsKey(self, key: ModelItem) -> bool: ...
    @overload
    def ContainsKey(self, key: Object) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self, key: ModelItem) -> ModelItem: ...
    @property
    def Item(self, key: Object) -> ModelItem: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def Values(self) -> ICollection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def remove_CollectionChanged(self, value: NotifyCollectionChangedEventHandler) -> None: ...
    @overload
    def Remove(self, key: Object) -> bool: ...
    @overload
    def Remove(self, key: ModelItem) -> bool: ...
    @Item.setter
    def Item(self, key: Object, value: ModelItem) -> None: ...
    @Item.setter
    def Item(self, key: ModelItem, value: ModelItem) -> None: ...
    @overload
    def TryGetValue(self, key: Object) -> Tuple[bool, ModelItem]: ...
    @overload
    def TryGetValue(self, key: ModelItem) -> Tuple[bool, ModelItem]: ...


class ModelItemExtensions(Object):
    @overload
    def Focus(item: ModelItem) -> None: ...
    @overload
    def Focus(item: ModelItem, level: int) -> None: ...
    def GetEditingContext(modelItem: ModelItem) -> EditingContext: ...
    def GetModelItemFromPath(path: str, root: ModelItem) -> ModelItem: ...
    def GetModelPath(modelItem: ModelItem) -> str: ...
    def IsParentOf(item: ModelItem, child: ModelItem) -> bool: ...




class ModelProperty(Object):
    def ClearValue(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AttachedOwnerType(self) -> Type: ...
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Collection(self) -> ModelItemCollection: ...
    @property
    def ComputedValue(self) -> Object: ...
    @property
    def Converter(self) -> TypeConverter: ...
    @property
    def DefaultValue(self) -> Object: ...
    @property
    def Dictionary(self) -> ModelItemDictionary: ...
    @property
    def IsAttached(self) -> bool: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsCollection(self) -> bool: ...
    @property
    def IsDictionary(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSet(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def Parent(self) -> ModelItem: ...
    @property
    def PropertyType(self) -> Type: ...
    @property
    def Value(self) -> ModelItem: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(first: ModelProperty, second: ModelProperty) -> bool: ...
    def op_Inequality(first: ModelProperty, second: ModelProperty) -> bool: ...
    @ComputedValue.setter
    def ComputedValue(self, value: Object) -> None: ...
    def SetValue(self, value: Object) -> ModelItem: ...


class ModelPropertyCollection:
    pass


class ModelTreeManager(Object):
    def __init__(self, context: EditingContext): ...
    def add_EditingScopeCompleted(self, value: EventHandler) -> None: ...
    def CreateModelItem(self, parent: ModelItem, instance: Object) -> ModelItem: ...
    @property
    def Root(self) -> ModelItem: ...
    def GetModelItem(self, instance: Object, shouldExpandModelTree: bool) -> ModelItem: ...
    def Load(self, rootInstance: Object) -> None: ...
    def remove_EditingScopeCompleted(self, value: EventHandler) -> None: ...


class MorphHelper(Object):
    def AddPropertyValueMorphHelper(propertyType: Type, extension: PropertyValueMorphHelper) -> None: ...
    def GetPropertyValueMorphHelper(propertyType: Type) -> PropertyValueMorphHelper: ...
    def MorphObject(oldModelItem: ModelItem, newModelitem: ModelItem) -> None: ...
    def MorphProperties(oldModelItem: ModelItem, newModelitem: ModelItem) -> None: ...


class PropertyValueMorphHelper(MulticastDelegate):
    def __init__(self, object: Object, method: IntPtr): ...
    def BeginInvoke(self, originalValue: ModelItem, newModelProperty: ModelProperty, callback: AsyncCallback, object: Object) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> Object: ...
    def Invoke(self, originalValue: ModelItem, newModelProperty: ModelProperty) -> Object: ...


class TextImage(Object):
    def __init__(self): ...
    @property
    def Lines(self) -> List[str]: ...
    @property
    def StartLineIndex(self) -> int: ...
    @StartLineIndex.setter
    def StartLineIndex(self, value: int) -> None: ...
