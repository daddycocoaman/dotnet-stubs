__all__ = ['Adornments','Classification','Differencing','Document','Editor','Formatting','IncrementalSearch','Operations','Outlining','Projection','Storage','Tagging','Utilities']
from typing import Tuple, Set, Iterable, List


class ContentTypeChangedEventArgs(TextSnapshotChangedEventArgs):
    def __init__(self, beforeSnapshot: ITextSnapshot, afterSnapshot: ITextSnapshot, beforeContentType: IContentType, afterContentType: IContentType, editTag: Object): ...
    @property
    def AfterContentType(self) -> IContentType: ...
    @property
    def BeforeContentType(self) -> IContentType: ...


class CustomTrackToVersion:
    def __init__(self, object: Object, method: IntPtr): ...
    def BeginInvoke(self, customSpan: ITrackingSpan, currentVersion: ITextVersion, targetVersion: ITextVersion, currentSpan: Span, customState: Object, callback: AsyncCallback, object: Object) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> Span: ...
    def Invoke(self, customSpan: ITrackingSpan, currentVersion: ITextVersion, targetVersion: ITextVersion, currentSpan: Span, customState: Object) -> Span: ...


class DynamicReadOnlyRegionQuery:
    def __init__(self, object: Object, method: IntPtr): ...
    def BeginInvoke(self, isEdit: bool, callback: AsyncCallback, object: Object) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> bool: ...
    def Invoke(self, isEdit: bool) -> bool: ...


class EdgeInsertionMode:
    Allow = 0
    Deny = 1


class EditOptions:
    @overload
    def __init__(self, differenceOptions: StringDifferenceOptions): ...
    @overload
    def __init__(self, computeMinimalChange: bool, differenceOptions: StringDifferenceOptions): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ComputeMinimalChange(self) -> bool: ...
    @property
    def DifferenceOptions(self) -> StringDifferenceOptions: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: EditOptions, right: EditOptions) -> bool: ...
    def op_Inequality(left: EditOptions, right: EditOptions) -> bool: ...
    def ToString(self) -> str: ...


class EncodingChangedEventArgs:
    def __init__(self, oldEncoding: Encoding, newEncoding: Encoding): ...
    @property
    def NewEncoding(self) -> Encoding: ...
    @property
    def OldEncoding(self) -> Encoding: ...


class FileActionTypes:
    ContentSavedToDisk = 1
    ContentLoadedFromDisk = 2
    DocumentRenamed = 4


class IEncodingDetector:
    def GetStreamEncoding(self, stream: Stream) -> Encoding: ...


class IExtensionErrorHandler:
    def HandleError(self, sender: Object, exception: Exception) -> None: ...


class IMappingPoint:
    @property
    def AnchorBuffer(self) -> ITextBuffer: ...
    @property
    def BufferGraph(self) -> IBufferGraph: ...
    def GetInsertionPoint(self, match: Predicate) -> Nullable: ...
    @overload
    def GetPoint(self, targetBuffer: ITextBuffer, affinity: PositionAffinity) -> Nullable: ...
    @overload
    def GetPoint(self, targetSnapshot: ITextSnapshot, affinity: PositionAffinity) -> Nullable: ...
    @overload
    def GetPoint(self, match: Predicate, affinity: PositionAffinity) -> Nullable: ...


class IMappingSpan:
    @property
    def AnchorBuffer(self) -> ITextBuffer: ...
    @property
    def BufferGraph(self) -> IBufferGraph: ...
    @property
    def End(self) -> IMappingPoint: ...
    @property
    def Start(self) -> IMappingPoint: ...
    @overload
    def GetSpans(self, targetBuffer: ITextBuffer) -> NormalizedSnapshotSpanCollection: ...
    @overload
    def GetSpans(self, targetSnapshot: ITextSnapshot) -> NormalizedSnapshotSpanCollection: ...
    @overload
    def GetSpans(self, match: Predicate) -> NormalizedSnapshotSpanCollection: ...


class INormalizedTextChangeCollection:
    @property
    def IncludesLineChanges(self) -> bool: ...


class IReadOnlyRegion:
    @property
    def EdgeInsertionMode(self) -> EdgeInsertionMode: ...
    @property
    def QueryCallback(self) -> DynamicReadOnlyRegionQuery: ...
    @property
    def Span(self) -> ITrackingSpan: ...


class IReadOnlyRegionEdit:
    def CreateDynamicReadOnlyRegion(self, span: Span, trackingMode: SpanTrackingMode, edgeInsertionMode: EdgeInsertionMode, callback: DynamicReadOnlyRegionQuery) -> IReadOnlyRegion: ...
    @overload
    def CreateReadOnlyRegion(self, span: Span) -> IReadOnlyRegion: ...
    @overload
    def CreateReadOnlyRegion(self, span: Span, trackingMode: SpanTrackingMode, edgeInsertionMode: EdgeInsertionMode) -> IReadOnlyRegion: ...
    def RemoveReadOnlyRegion(self, readOnlyRegion: IReadOnlyRegion) -> None: ...


class ITextBuffer:
    def add_Changed(self, value: EventHandler) -> None: ...
    def add_ChangedHighPriority(self, value: EventHandler) -> None: ...
    def add_ChangedLowPriority(self, value: EventHandler) -> None: ...
    def add_Changing(self, value: EventHandler) -> None: ...
    def add_ContentTypeChanged(self, value: EventHandler) -> None: ...
    def add_PostChanged(self, value: EventHandler) -> None: ...
    def add_ReadOnlyRegionsChanged(self, value: EventHandler) -> None: ...
    def ChangeContentType(self, newContentType: IContentType, editTag: Object) -> None: ...
    def CheckEditAccess(self) -> bool: ...
    @overload
    def CreateEdit(self) -> ITextEdit: ...
    @overload
    def CreateEdit(self, options: EditOptions, reiteratedVersionNumber: Nullable, editTag: Object) -> ITextEdit: ...
    def CreateReadOnlyRegionEdit(self) -> IReadOnlyRegionEdit: ...
    def Delete(self, deleteSpan: Span) -> ITextSnapshot: ...
    @property
    def ContentType(self) -> IContentType: ...
    @property
    def CurrentSnapshot(self) -> ITextSnapshot: ...
    @property
    def EditInProgress(self) -> bool: ...
    def GetReadOnlyExtents(self, span: Span) -> NormalizedSpanCollection: ...
    def Insert(self, position: int, text: str) -> ITextSnapshot: ...
    @overload
    def IsReadOnly(self, position: int) -> bool: ...
    @overload
    def IsReadOnly(self, span: Span) -> bool: ...
    @overload
    def IsReadOnly(self, position: int, isEdit: bool) -> bool: ...
    @overload
    def IsReadOnly(self, span: Span, isEdit: bool) -> bool: ...
    def remove_Changed(self, value: EventHandler) -> None: ...
    def remove_ChangedHighPriority(self, value: EventHandler) -> None: ...
    def remove_ChangedLowPriority(self, value: EventHandler) -> None: ...
    def remove_Changing(self, value: EventHandler) -> None: ...
    def remove_ContentTypeChanged(self, value: EventHandler) -> None: ...
    def remove_PostChanged(self, value: EventHandler) -> None: ...
    def remove_ReadOnlyRegionsChanged(self, value: EventHandler) -> None: ...
    def Replace(self, replaceSpan: Span, replaceWith: str) -> ITextSnapshot: ...
    def TakeThreadOwnership(self) -> None: ...


class ITextBufferEdit:
    def Apply(self) -> ITextSnapshot: ...
    def Cancel(self) -> None: ...
    @property
    def Canceled(self) -> bool: ...
    @property
    def Snapshot(self) -> ITextSnapshot: ...


class ITextBufferFactoryService:
    def add_TextBufferCreated(self, value: EventHandler) -> None: ...
    @overload
    def CreateTextBuffer(self) -> ITextBuffer: ...
    @overload
    def CreateTextBuffer(self, contentType: IContentType) -> ITextBuffer: ...
    @overload
    def CreateTextBuffer(self, text: str, contentType: IContentType) -> ITextBuffer: ...
    @overload
    def CreateTextBuffer(self, reader: TextReader, contentType: IContentType) -> ITextBuffer: ...
    @property
    def InertContentType(self) -> IContentType: ...
    @property
    def PlaintextContentType(self) -> IContentType: ...
    @property
    def TextContentType(self) -> IContentType: ...
    def remove_TextBufferCreated(self, value: EventHandler) -> None: ...


class ITextChange:
    @property
    def Delta(self) -> int: ...
    @property
    def LineCountDelta(self) -> int: ...
    @property
    def NewEnd(self) -> int: ...
    @property
    def NewLength(self) -> int: ...
    @property
    def NewPosition(self) -> int: ...
    @property
    def NewSpan(self) -> Span: ...
    @property
    def NewText(self) -> str: ...
    @property
    def OldEnd(self) -> int: ...
    @property
    def OldLength(self) -> int: ...
    @property
    def OldPosition(self) -> int: ...
    @property
    def OldSpan(self) -> Span: ...
    @property
    def OldText(self) -> str: ...


class ITextDataModel:
    def add_ContentTypeChanged(self, value: EventHandler) -> None: ...
    @property
    def ContentType(self) -> IContentType: ...
    @property
    def DataBuffer(self) -> ITextBuffer: ...
    @property
    def DocumentBuffer(self) -> ITextBuffer: ...
    def remove_ContentTypeChanged(self, value: EventHandler) -> None: ...


class ITextDocument:
    def add_DirtyStateChanged(self, value: EventHandler) -> None: ...
    def add_EncodingChanged(self, value: EventHandler) -> None: ...
    def add_FileActionOccurred(self, value: EventHandler) -> None: ...
    @property
    def Encoding(self) -> Encoding: ...
    @property
    def FilePath(self) -> str: ...
    @property
    def IsDirty(self) -> bool: ...
    @property
    def IsReloading(self) -> bool: ...
    @property
    def LastContentModifiedTime(self) -> DateTime: ...
    @property
    def LastSavedTime(self) -> DateTime: ...
    @property
    def TextBuffer(self) -> ITextBuffer: ...
    @overload
    def Reload(self) -> ReloadResult: ...
    @overload
    def Reload(self, options: EditOptions) -> ReloadResult: ...
    def remove_DirtyStateChanged(self, value: EventHandler) -> None: ...
    def remove_EncodingChanged(self, value: EventHandler) -> None: ...
    def remove_FileActionOccurred(self, value: EventHandler) -> None: ...
    def Rename(self, newFilePath: str) -> None: ...
    def Save(self) -> None: ...
    @overload
    def SaveAs(self, filePath: str, overwrite: bool) -> None: ...
    @overload
    def SaveAs(self, filePath: str, overwrite: bool, createFolder: bool) -> None: ...
    @overload
    def SaveAs(self, filePath: str, overwrite: bool, newContentType: IContentType) -> None: ...
    @overload
    def SaveAs(self, filePath: str, overwrite: bool, createFolder: bool, newContentType: IContentType) -> None: ...
    @overload
    def SaveCopy(self, filePath: str, overwrite: bool) -> None: ...
    @overload
    def SaveCopy(self, filePath: str, overwrite: bool, createFolder: bool) -> None: ...
    @Encoding.setter
    def Encoding(self, value: Encoding) -> None: ...
    def SetEncoderFallback(self, fallback: EncoderFallback) -> None: ...
    def UpdateDirtyState(self, isDirty: bool, lastContentModifiedTime: DateTime) -> None: ...


class ITextDocumentFactoryService:
    def add_TextDocumentCreated(self, value: EventHandler) -> None: ...
    def add_TextDocumentDisposed(self, value: EventHandler) -> None: ...
    @overload
    def CreateAndLoadTextDocument(self, filePath: str, contentType: IContentType) -> ITextDocument: ...
    @overload
    def CreateAndLoadTextDocument(self, filePath: str, contentType: IContentType, encoding: Encoding) -> Tuple[ITextDocument, bool]: ...
    @overload
    def CreateAndLoadTextDocument(self, filePath: str, contentType: IContentType, attemptUtf8Detection: bool) -> Tuple[ITextDocument, bool]: ...
    def CreateTextDocument(self, textBuffer: ITextBuffer, filePath: str) -> ITextDocument: ...
    def remove_TextDocumentCreated(self, value: EventHandler) -> None: ...
    def remove_TextDocumentDisposed(self, value: EventHandler) -> None: ...
    def TryGetTextDocument(self, textBuffer: ITextBuffer) -> Tuple[bool, ITextDocument]: ...


class ITextEdit:
    @overload
    def Delete(self, deleteSpan: Span) -> bool: ...
    @overload
    def Delete(self, startPosition: int, charsToDelete: int) -> bool: ...
    @property
    def HasEffectiveChanges(self) -> bool: ...
    @property
    def HasFailedChanges(self) -> bool: ...
    @overload
    def Insert(self, position: int, text: str) -> bool: ...
    @overload
    def Insert(self, position: int, characterBuffer: Set(Char), startIndex: int, length: int) -> bool: ...
    @overload
    def Replace(self, replaceSpan: Span, replaceWith: str) -> bool: ...
    @overload
    def Replace(self, startPosition: int, charsToReplace: int, replaceWith: str) -> bool: ...


class ITextSnapshot:
    def CopyTo(self, sourceIndex: int, destination: Set(Char), destinationIndex: int, count: int) -> None: ...
    @overload
    def CreateTrackingPoint(self, position: int, trackingMode: PointTrackingMode) -> ITrackingPoint: ...
    @overload
    def CreateTrackingPoint(self, position: int, trackingMode: PointTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingPoint: ...
    @overload
    def CreateTrackingSpan(self, span: Span, trackingMode: SpanTrackingMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, start: int, length: int, trackingMode: SpanTrackingMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, span: Span, trackingMode: SpanTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, start: int, length: int, trackingMode: SpanTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingSpan: ...
    @property
    def ContentType(self) -> IContentType: ...
    @property
    def Item(self, position: int) -> Char: ...
    @property
    def Length(self) -> int: ...
    @property
    def LineCount(self) -> int: ...
    @property
    def Lines(self) -> Iterable[ITextSnapshotLine]: ...
    @property
    def TextBuffer(self) -> ITextBuffer: ...
    @property
    def Version(self) -> ITextVersion: ...
    def GetLineFromLineNumber(self, lineNumber: int) -> ITextSnapshotLine: ...
    def GetLineFromPosition(self, position: int) -> ITextSnapshotLine: ...
    def GetLineNumberFromPosition(self, position: int) -> int: ...
    @overload
    def GetText(self) -> str: ...
    @overload
    def GetText(self, span: Span) -> str: ...
    @overload
    def GetText(self, startIndex: int, length: int) -> str: ...
    def ToCharArray(self, startIndex: int, length: int) -> Set(Char): ...
    @overload
    def Write(self, writer: TextWriter) -> None: ...
    @overload
    def Write(self, writer: TextWriter, span: Span) -> None: ...


class ITextSnapshotLine:
    @property
    def End(self) -> SnapshotPoint: ...
    @property
    def EndIncludingLineBreak(self) -> SnapshotPoint: ...
    @property
    def Extent(self) -> SnapshotSpan: ...
    @property
    def ExtentIncludingLineBreak(self) -> SnapshotSpan: ...
    @property
    def Length(self) -> int: ...
    @property
    def LengthIncludingLineBreak(self) -> int: ...
    @property
    def LineBreakLength(self) -> int: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def Snapshot(self) -> ITextSnapshot: ...
    @property
    def Start(self) -> SnapshotPoint: ...
    def GetLineBreakText(self) -> str: ...
    def GetText(self) -> str: ...
    def GetTextIncludingLineBreak(self) -> str: ...


class ITextVersion:
    def CreateCustomTrackingSpan(self, span: Span, trackingFidelity: TrackingFidelityMode, customState: Object, behavior: CustomTrackToVersion) -> ITrackingSpan: ...
    @overload
    def CreateTrackingPoint(self, position: int, trackingMode: PointTrackingMode) -> ITrackingPoint: ...
    @overload
    def CreateTrackingPoint(self, position: int, trackingMode: PointTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingPoint: ...
    @overload
    def CreateTrackingSpan(self, span: Span, trackingMode: SpanTrackingMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, span: Span, trackingMode: SpanTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, start: int, length: int, trackingMode: SpanTrackingMode) -> ITrackingSpan: ...
    @overload
    def CreateTrackingSpan(self, start: int, length: int, trackingMode: SpanTrackingMode, trackingFidelity: TrackingFidelityMode) -> ITrackingSpan: ...
    @property
    def Changes(self) -> INormalizedTextChangeCollection: ...
    @property
    def Length(self) -> int: ...
    @property
    def Next(self) -> ITextVersion: ...
    @property
    def ReiteratedVersionNumber(self) -> int: ...
    @property
    def TextBuffer(self) -> ITextBuffer: ...
    @property
    def VersionNumber(self) -> int: ...


class ITrackingPoint:
    @property
    def TextBuffer(self) -> ITextBuffer: ...
    @property
    def TrackingFidelity(self) -> TrackingFidelityMode: ...
    @property
    def TrackingMode(self) -> PointTrackingMode: ...
    def GetCharacter(self, snapshot: ITextSnapshot) -> Char: ...
    def GetPoint(self, snapshot: ITextSnapshot) -> SnapshotPoint: ...
    @overload
    def GetPosition(self, snapshot: ITextSnapshot) -> int: ...
    @overload
    def GetPosition(self, version: ITextVersion) -> int: ...


class ITrackingSpan:
    @property
    def TextBuffer(self) -> ITextBuffer: ...
    @property
    def TrackingFidelity(self) -> TrackingFidelityMode: ...
    @property
    def TrackingMode(self) -> SpanTrackingMode: ...
    def GetEndPoint(self, snapshot: ITextSnapshot) -> SnapshotPoint: ...
    @overload
    def GetSpan(self, snapshot: ITextSnapshot) -> SnapshotSpan: ...
    @overload
    def GetSpan(self, version: ITextVersion) -> Span: ...
    def GetStartPoint(self, snapshot: ITextSnapshot) -> SnapshotPoint: ...
    def GetText(self, snapshot: ITextSnapshot) -> str: ...


class NormalizedSnapshotSpanCollection:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, span: SnapshotSpan): ...
    @overload
    def __init__(self, snapshotSpans: Iterable[SnapshotSpan]): ...
    @overload
    def __init__(self, snapshot: ITextSnapshot, spans: NormalizedSpanCollection): ...
    @overload
    def __init__(self, snapshot: ITextSnapshot, spans: Iterable[Span]): ...
    @overload
    def Contains(self, value: Object) -> bool: ...
    @overload
    def Contains(self, item: SnapshotSpan) -> bool: ...
    @overload
    def CopyTo(self, array: Set(SnapshotSpan), arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Difference(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> NormalizedSnapshotSpanCollection: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self, index: int) -> SnapshotSpan: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetHashCode(self) -> int: ...
    @overload
    def IndexOf(self, item: SnapshotSpan) -> int: ...
    @overload
    def IndexOf(self, value: Object) -> int: ...
    def Intersection(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> NormalizedSnapshotSpanCollection: ...
    def IntersectsWith(self, set: NormalizedSnapshotSpanCollection) -> bool: ...
    def op_Equality(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> bool: ...
    def op_Implicit(spans: NormalizedSnapshotSpanCollection) -> NormalizedSpanCollection: ...
    def op_Inequality(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> bool: ...
    def Overlap(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> NormalizedSnapshotSpanCollection: ...
    def OverlapsWith(self, set: NormalizedSnapshotSpanCollection) -> bool: ...
    @Item.setter
    def Item(self, index: int, value: SnapshotSpan) -> None: ...
    def ToString(self) -> str: ...
    def Union(left: NormalizedSnapshotSpanCollection, right: NormalizedSnapshotSpanCollection) -> NormalizedSnapshotSpanCollection: ...


class NormalizedSpanCollection:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, span: Span): ...
    @overload
    def __init__(self, spans: Iterable[Span]): ...
    def Difference(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> NormalizedSpanCollection: ...
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Intersection(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> NormalizedSpanCollection: ...
    def IntersectsWith(self, set: NormalizedSpanCollection) -> bool: ...
    def op_Equality(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> bool: ...
    def op_Inequality(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> bool: ...
    def Overlap(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> NormalizedSpanCollection: ...
    def OverlapsWith(self, set: NormalizedSpanCollection) -> bool: ...
    def ToString(self) -> str: ...
    def Union(left: NormalizedSpanCollection, right: NormalizedSpanCollection) -> NormalizedSpanCollection: ...


class PointTrackingMode:
    Positive = 0
    Negative = 1


class PositionAffinity:
    Predecessor = 0
    Successor = 1


class PreContentChangedEventArgs:
    def __init__(self, beforeSnapshot: ITextSnapshot, changes: INormalizedTextChangeCollection): ...
    @property
    def BeforeSnapshot(self) -> ITextSnapshot: ...
    @property
    def Changes(self) -> INormalizedTextChangeCollection: ...


class ReloadResult:
    Aborted = 0
    Succeeded = 1
    SucceededWithCharacterSubstitutions = 2


class SnapshotPoint:
    def __init__(self, snapshot: ITextSnapshot, position: int): ...
    def Add(self, offset: int) -> SnapshotPoint: ...
    def CompareTo(self, other: SnapshotPoint) -> int: ...
    def Difference(self, other: SnapshotPoint) -> int: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Position(self) -> int: ...
    @property
    def Snapshot(self) -> ITextSnapshot: ...
    def GetChar(self) -> Char: ...
    def GetContainingLine(self) -> ITextSnapshotLine: ...
    def GetHashCode(self) -> int: ...
    def op_Addition(point: SnapshotPoint, offset: int) -> SnapshotPoint: ...
    def op_Equality(left: SnapshotPoint, right: SnapshotPoint) -> bool: ...
    def op_GreaterThan(left: SnapshotPoint, right: SnapshotPoint) -> bool: ...
    def op_Implicit(snapshotPoint: SnapshotPoint) -> int: ...
    def op_Inequality(left: SnapshotPoint, right: SnapshotPoint) -> bool: ...
    def op_LessThan(left: SnapshotPoint, right: SnapshotPoint) -> bool: ...
    @overload
    def op_Subtraction(point: SnapshotPoint, offset: int) -> SnapshotPoint: ...
    @overload
    def op_Subtraction(start: SnapshotPoint, other: SnapshotPoint) -> int: ...
    def Subtract(self, offset: int) -> SnapshotPoint: ...
    def ToString(self) -> str: ...
    def TranslateTo(self, targetSnapshot: ITextSnapshot, trackingMode: PointTrackingMode) -> SnapshotPoint: ...


class SnapshotSpan:
    @overload
    def __init__(self, snapshot: ITextSnapshot, span: Span): ...
    @overload
    def __init__(self, start: SnapshotPoint, end: SnapshotPoint): ...
    @overload
    def __init__(self, start: SnapshotPoint, length: int): ...
    @overload
    def __init__(self, snapshot: ITextSnapshot, start: int, length: int): ...
    @overload
    def Contains(self, position: int) -> bool: ...
    @overload
    def Contains(self, point: SnapshotPoint) -> bool: ...
    @overload
    def Contains(self, simpleSpan: Span) -> bool: ...
    @overload
    def Contains(self, snapshotSpan: SnapshotSpan) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def End(self) -> SnapshotPoint: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Snapshot(self) -> ITextSnapshot: ...
    @property
    def Span(self) -> Span: ...
    @property
    def Start(self) -> SnapshotPoint: ...
    def GetHashCode(self) -> int: ...
    def GetText(self) -> str: ...
    @overload
    def Intersection(self, snapshotSpan: SnapshotSpan) -> Nullable: ...
    @overload
    def Intersection(self, simpleSpan: Span) -> Nullable: ...
    @overload
    def IntersectsWith(self, simpleSpan: Span) -> bool: ...
    @overload
    def IntersectsWith(self, snapshotSpan: SnapshotSpan) -> bool: ...
    def op_Equality(left: SnapshotSpan, right: SnapshotSpan) -> bool: ...
    def op_Implicit(snapshotSpan: SnapshotSpan) -> Span: ...
    def op_Inequality(left: SnapshotSpan, right: SnapshotSpan) -> bool: ...
    @overload
    def Overlap(self, simpleSpan: Span) -> Nullable: ...
    @overload
    def Overlap(self, snapshotSpan: SnapshotSpan) -> Nullable: ...
    @overload
    def OverlapsWith(self, snapshotSpan: SnapshotSpan) -> bool: ...
    @overload
    def OverlapsWith(self, simpleSpan: Span) -> bool: ...
    def ToString(self) -> str: ...
    def TranslateTo(self, targetSnapshot: ITextSnapshot, spanTrackingMode: SpanTrackingMode) -> SnapshotSpan: ...


class SnapshotSpanEventArgs:
    def __init__(self, span: SnapshotSpan): ...
    @property
    def Span(self) -> SnapshotSpan: ...


class Span:
    def __init__(self, start: int, length: int): ...
    @overload
    def Contains(self, position: int) -> bool: ...
    @overload
    def Contains(self, span: Span) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    def FromBounds(start: int, end: int) -> Span: ...
    @property
    def End(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Start(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def Intersection(self, span: Span) -> Nullable: ...
    def IntersectsWith(self, span: Span) -> bool: ...
    def op_Equality(left: Span, right: Span) -> bool: ...
    def op_Inequality(left: Span, right: Span) -> bool: ...
    def Overlap(self, span: Span) -> Nullable: ...
    def OverlapsWith(self, span: Span) -> bool: ...
    def ToString(self) -> str: ...


class SpanTrackingMode:
    EdgeExclusive = 0
    EdgeInclusive = 1
    EdgePositive = 2
    EdgeNegative = 3
    Custom = 4


class TextBufferCreatedEventArgs:
    def __init__(self, textBuffer: ITextBuffer): ...
    @property
    def TextBuffer(self) -> ITextBuffer: ...


class TextContentChangedEventArgs(TextSnapshotChangedEventArgs):
    def __init__(self, beforeSnapshot: ITextSnapshot, afterSnapshot: ITextSnapshot, options: EditOptions, editTag: Object): ...
    @property
    def Changes(self) -> INormalizedTextChangeCollection: ...
    @property
    def Options(self) -> EditOptions: ...


class TextContentChangingEventArgs:
    def __init__(self, beforeSnapshot: ITextSnapshot, editTag: Object, cancelAction: Action): ...
    def Cancel(self) -> None: ...
    @property
    def Before(self) -> ITextSnapshot: ...
    @property
    def BeforeVersion(self) -> ITextVersion: ...
    @property
    def Canceled(self) -> bool: ...
    @property
    def EditTag(self) -> Object: ...


class TextDataModelContentTypeChangedEventArgs:
    def __init__(self, beforeContentType: IContentType, afterContentType: IContentType): ...
    @property
    def AfterContentType(self) -> IContentType: ...
    @property
    def BeforeContentType(self) -> IContentType: ...


class TextDocumentEventArgs:
    def __init__(self, textDocument: ITextDocument): ...
    @property
    def TextDocument(self) -> ITextDocument: ...


class TextDocumentFileActionEventArgs:
    def __init__(self, filePath: str, time: DateTime, fileActionType: FileActionTypes): ...
    @property
    def FileActionType(self) -> FileActionTypes: ...
    @property
    def FilePath(self) -> str: ...
    @property
    def Time(self) -> DateTime: ...


class TextSnapshotChangedEventArgs:
    @property
    def After(self) -> ITextSnapshot: ...
    @property
    def AfterVersion(self) -> ITextVersion: ...
    @property
    def Before(self) -> ITextSnapshot: ...
    @property
    def BeforeVersion(self) -> ITextVersion: ...
    @property
    def EditTag(self) -> Object: ...


class TextSnapshotToTextReader:
    def __init__(self, textSnapshot: ITextSnapshot): ...
    def Close(self) -> None: ...
    def Peek(self) -> int: ...
    @overload
    def Read(self) -> int: ...
    @overload
    def Read(self, buffer: Set(Char), index: int, count: int) -> int: ...
    def ReadBlock(self, buffer: Set(Char), index: int, count: int) -> int: ...
    def ReadLine(self) -> str: ...
    def ReadToEnd(self) -> str: ...


class TrackingFidelityMode:
    Forward = 0
    Backward = 1
    UndoRedo = 2


class VirtualSnapshotPoint:
    @overload
    def __init__(self, position: SnapshotPoint): ...
    @overload
    def __init__(self, snapshot: ITextSnapshot, position: int): ...
    @overload
    def __init__(self, position: SnapshotPoint, virtualSpaces: int): ...
    @overload
    def __init__(self, line: ITextSnapshotLine, offset: int): ...
    def CompareTo(self, other: VirtualSnapshotPoint) -> int: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsInVirtualSpace(self) -> bool: ...
    @property
    def Position(self) -> SnapshotPoint: ...
    @property
    def VirtualSpaces(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def op_GreaterThan(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def op_GreaterThanOrEqual(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def op_Inequality(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def op_LessThan(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def op_LessThanOrEqual(left: VirtualSnapshotPoint, right: VirtualSnapshotPoint) -> bool: ...
    def ToString(self) -> str: ...
    @overload
    def TranslateTo(self, snapshot: ITextSnapshot) -> VirtualSnapshotPoint: ...
    @overload
    def TranslateTo(self, snapshot: ITextSnapshot, trackingMode: PointTrackingMode) -> VirtualSnapshotPoint: ...


class VirtualSnapshotSpan:
    @overload
    def __init__(self, snapshotSpan: SnapshotSpan): ...
    @overload
    def __init__(self, start: VirtualSnapshotPoint, end: VirtualSnapshotPoint): ...
    @overload
    def Contains(self, virtualPoint: VirtualSnapshotPoint) -> bool: ...
    @overload
    def Contains(self, virtualSpan: VirtualSnapshotSpan) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def End(self) -> VirtualSnapshotPoint: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def IsInVirtualSpace(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Snapshot(self) -> ITextSnapshot: ...
    @property
    def SnapshotSpan(self) -> SnapshotSpan: ...
    @property
    def Start(self) -> VirtualSnapshotPoint: ...
    def GetHashCode(self) -> int: ...
    def GetText(self) -> str: ...
    def Intersection(self, virtualSpan: VirtualSnapshotSpan) -> Nullable: ...
    def IntersectsWith(self, virtualSpan: VirtualSnapshotSpan) -> bool: ...
    def op_Equality(left: VirtualSnapshotSpan, right: VirtualSnapshotSpan) -> bool: ...
    def op_Inequality(left: VirtualSnapshotSpan, right: VirtualSnapshotSpan) -> bool: ...
    def Overlap(self, virtualSpan: VirtualSnapshotSpan) -> Nullable: ...
    def OverlapsWith(self, virtualSpan: VirtualSnapshotSpan) -> bool: ...
    def ToString(self) -> str: ...
    @overload
    def TranslateTo(self, snapshot: ITextSnapshot) -> VirtualSnapshotSpan: ...
    @overload
    def TranslateTo(self, snapshot: ITextSnapshot, trackingMode: SpanTrackingMode) -> VirtualSnapshotSpan: ...
