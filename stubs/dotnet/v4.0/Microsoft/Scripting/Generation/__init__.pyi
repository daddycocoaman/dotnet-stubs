from typing import Tuple, Set, Iterable, List




class AssemblyGen:
    def __init__(self, name: AssemblyName, outDir: str, outFileExtension: str, isDebuggable: bool, attrs: IDictionary): ...
    def DefinePublicType(self, name: str, parent: Type, preserveName: bool) -> TypeBuilder: ...
    @property
    def AssemblyBuilder(self) -> AssemblyBuilder: ...
    @property
    def ModuleBuilder(self) -> ModuleBuilder: ...
    def MakeDelegateType(self, name: str, parameters: Set(Type), returnType: Type) -> Type: ...
    def SaveAssembly(self) -> str: ...


class CompilerHelpers:
    def CanEmitConstant(value: Object, type: Type) -> bool: ...
    def CanOptimizeMethod(method: MethodBase) -> bool: ...
    def Compile(lambda: Expression, emitDebugSymbols: bool) -> T: ...
    @overload
    def CompileToMethod(lambda: LambdaExpression, method: MethodBuilder, emitDebugSymbols: bool) -> None: ...
    @overload
    def CompileToMethod(lambda: Expression, debugInfoGenerator: DebugInfoGenerator, emitDebugSymbols: bool) -> T: ...
    @overload
    def CompileToMethod(lambda: LambdaExpression, debugInfoGenerator: DebugInfoGenerator, emitDebugSymbols: bool) -> Delegate: ...
    @overload
    def CreateBigInteger(value: Int64) -> BigInteger: ...
    @overload
    def CreateBigInteger(value: int) -> BigInteger: ...
    @overload
    def CreateBigInteger(isNegative: bool, data: Set(Byte)) -> BigInteger: ...
    def FilterConstructorsToPublicAndProtected(ctors: Iterable[ConstructorInfo]) -> Iterable[ConstructorInfo]: ...
    def FilterNonVisibleMembers(targetType: Type, members: Iterable[MemberInfo]) -> Iterable[MemberInfo]: ...
    def FilterNonVisibleMembersIterator(targetType: Type, members: Iterable[MemberInfo]) -> Iterable[MemberInfo]: ...
    @overload
    def GetConstructors(t: Type, privateBinding: bool) -> Set(MethodBase): ...
    @overload
    def GetConstructors(t: Type, privateBinding: bool, includeProtected: bool) -> Set(MethodBase): ...
    def GetExplicitConverter(fromType: Type, toType: Type) -> MethodInfo: ...
    def GetExpressionTypes(expressions: Set(Expression)) -> Set(Type): ...
    def GetImplicitConverter(fromType: Type, toType: Type) -> MethodInfo: ...
    def GetMethodTargets(obj: Object) -> Set(MethodBase): ...
    def GetMissingValue(type: Type) -> Object: ...
    def GetSiteTypes(arguments: List[Expression], returnType: Type) -> Set(Type): ...
    def GetTryConvertReturnValue(type: Type) -> Expression: ...
    @overload
    def GetType(obj: Object) -> Type: ...
    def GetTypes(args: Set(Object)) -> Set(Type): ...
    def GetUniqueMethodName() -> str: ...
    @overload
    def GetVisibleType(t: Type) -> Type: ...
    @overload
    def GetVisibleType(value: Object) -> Type: ...
    def HasTypeConverter(fromType: Type, toType: Type) -> bool: ...
    def IsComparisonOperator(op: ExpressionType) -> bool: ...
    def IsConstructor(mb: MethodBase) -> bool: ...
    @overload
    def IsProtected(info: MethodBase) -> bool: ...
    @overload
    def IsProtected(type: Type) -> bool: ...
    @overload
    def IsProtected(info: FieldInfo) -> bool: ...
    def IsStatic(mi: MethodBase) -> bool: ...
    @overload
    def IsStrongBox(t: Type) -> bool: ...
    @overload
    def IsStrongBox(target: Object) -> bool: ...
    @overload
    def IsVisible(info: FieldInfo) -> bool: ...
    @overload
    def IsVisible(info: MethodBase) -> bool: ...
    @overload
    def LightCompile(lambda: Expression) -> T: ...
    @overload
    def LightCompile(lambda: LambdaExpression) -> Delegate: ...
    @overload
    def LightCompile(lambda: LambdaExpression, compilationThreshold: int) -> Delegate: ...
    @overload
    def LightCompile(lambda: Expression, compilationThreshold: int) -> T: ...
    def MakeCallSiteDelegateType(types: Set(Type)) -> Type: ...
    def MakeCallSiteType(types: Set(Type)) -> Type: ...
    def MakeRepeatedArray(item: T, count: int) -> Set(T): ...
    def MemberEquals(self: MemberInfo, other: MemberInfo) -> bool: ...
    def Reduce(node: DynamicExpression) -> Expression: ...
    def TryApplyTypeConverter(value: Object, toType: Type) -> Tuple[bool, Object]: ...
    def TryGetCallableMethod(targetType: Type, method: MethodInfo) -> MethodInfo: ...
    def TryGetTypeConverter(fromType: Type, toType: Type) -> Tuple[bool, TypeConverter]: ...
    def TryGetVisibleMember(targetType: Type, member: MemberInfo) -> MemberInfo: ...
    def TryImplicitConversion(value: Object, to: Type) -> Tuple[bool, Object]: ...
    def TypesEqual(args: IList, start: int, types: Set(Type)) -> bool: ...


class ConstantCheck:
    def Check(expression: Expression, value: Object) -> bool: ...


class DynamicILGen(ILGen):
    @overload
    def CreateDelegate(self) -> T: ...
    @overload
    def CreateDelegate(self) -> Tuple[T, MethodInfo]: ...
    def Finish(self) -> MethodInfo: ...


class EmitArrayHelper:
    def __init__(self, object: Object, method: IntPtr): ...
    def BeginInvoke(self, index: int, callback: AsyncCallback, object: Object) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, index: int) -> None: ...


class FieldBuilderExpression:
    def __init__(self, builder: FieldBuilder): ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> Type: ...
    def Reduce(self) -> Expression: ...


class GeneratorOps:
    def BoxGeneric(value: T) -> Object: ...


class ILGen:
    def __init__(self, ilg: ILGenerator): ...
    def BeginCatchBlock(self, exceptionType: Type) -> None: ...
    def BeginExceptFilterBlock(self) -> None: ...
    def BeginExceptionBlock(self) -> Label: ...
    def BeginFaultBlock(self) -> None: ...
    def BeginFinallyBlock(self) -> None: ...
    def BeginScope(self) -> None: ...
    @overload
    def DeclareLocal(self, localType: Type) -> LocalBuilder: ...
    @overload
    def DeclareLocal(self, localType: Type, pinned: bool) -> LocalBuilder: ...
    def DefineLabel(self) -> Label: ...
    @overload
    def Emit(self, opcode: OpCode) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: SByte) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, label: Label) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, meth: MethodInfo) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: Int64) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, local: LocalBuilder) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, labels: Set(Label)) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: Int16) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: int) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: Byte) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, field: FieldInfo) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: float) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, con: ConstructorInfo) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, signature: SignatureHelper) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, cls: Type) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, arg: Single) -> None: ...
    @overload
    def Emit(self, opcode: OpCode, str: str) -> None: ...
    @overload
    def EmitArray(self, arrayType: Type) -> None: ...
    @overload
    def EmitArray(self, items: IList) -> None: ...
    @overload
    def EmitArray(self, elementType: Type, count: int, emit: EmitArrayHelper) -> None: ...
    def EmitBoolean(self, value: bool) -> None: ...
    def EmitBoxing(self, type: Type) -> None: ...
    def EmitByte(self, value: Byte) -> None: ...
    @overload
    def EmitCall(self, mi: MethodInfo) -> None: ...
    @overload
    def EmitCall(self, type: Type, name: str) -> None: ...
    @overload
    def EmitCall(self, opcode: OpCode, methodInfo: MethodInfo, optionalParameterTypes: Set(Type)) -> None: ...
    @overload
    def EmitCall(self, type: Type, name: str, paramTypes: Set(Type)) -> None: ...
    @overload
    def EmitCalli(self, opcode: OpCode, unmanagedCallConv: CallingConvention, returnType: Type, parameterTypes: Set(Type)) -> None: ...
    @overload
    def EmitCalli(self, opcode: OpCode, callingConvention: CallingConventions, returnType: Type, parameterTypes: Set(Type), optionalParameterTypes: Set(Type)) -> None: ...
    def EmitChar(self, value: Char) -> None: ...
    def EmitDecimal(self, value: Decimal) -> None: ...
    def EmitDouble(self, value: float) -> None: ...
    def EmitExplicitCast(self, from_: Type, to: Type) -> None: ...
    def EmitFieldAddress(self, fi: FieldInfo) -> None: ...
    def EmitFieldGet(self, fi: FieldInfo) -> None: ...
    def EmitFieldSet(self, fi: FieldInfo) -> None: ...
    def EmitImplicitCast(self, from_: Type, to: Type) -> None: ...
    def EmitInt(self, value: int) -> None: ...
    def EmitLoadArg(self, index: int) -> None: ...
    def EmitLoadArgAddress(self, index: int) -> None: ...
    def EmitLoadElement(self, type: Type) -> None: ...
    def EmitLoadValueIndirect(self, type: Type) -> None: ...
    def EmitLong(self, value: Int64) -> None: ...
    def EmitMissingValue(self, type: Type) -> None: ...
    @overload
    def EmitNew(self, ci: ConstructorInfo) -> None: ...
    @overload
    def EmitNew(self, type: Type, paramTypes: Set(Type)) -> None: ...
    def EmitNull(self) -> None: ...
    def EmitNumericCast(self, from_: Type, to: Type, implicitOnly: bool) -> bool: ...
    def EmitPropertyGet(self, pi: PropertyInfo) -> None: ...
    def EmitPropertySet(self, pi: PropertyInfo) -> None: ...
    def EmitSByte(self, value: SByte) -> None: ...
    def EmitShort(self, value: Int16) -> None: ...
    def EmitSingle(self, value: Single) -> None: ...
    def EmitStoreArg(self, index: int) -> None: ...
    def EmitStoreElement(self, type: Type) -> None: ...
    def EmitStoreValueIndirect(self, type: Type) -> None: ...
    def EmitString(self, value: str) -> None: ...
    def EmitType(self, type: Type) -> None: ...
    def EmitUInt(self, value: UInt32) -> None: ...
    def EmitULong(self, value: UInt64) -> None: ...
    def EmitUnbox(self, type: Type) -> None: ...
    def EmitUShort(self, value: UInt16) -> None: ...
    def EndExceptionBlock(self) -> None: ...
    def EndScope(self) -> None: ...
    def MarkLabel(self, loc: Label) -> None: ...
    def MarkSequencePoint(self, document: ISymbolDocumentWriter, startLine: int, startColumn: int, endLine: int, endColumn: int) -> None: ...
    @overload
    def ShouldLdtoken(t: Type) -> bool: ...
    @overload
    def ShouldLdtoken(mb: MethodBase) -> bool: ...
    def TryEmitExplicitCast(self, from_: Type, to: Type) -> bool: ...
    def TryEmitImplicitCast(self, from_: Type, to: Type) -> bool: ...
    def UsingNamespace(self, usingNamespace: str) -> None: ...


class MethodSignatureInfo:
    @overload
    def __init__(self, info: MethodInfo): ...
    @overload
    def __init__(self, isStatic: bool, pis: Set(ParameterInfo), genericArity: int): ...
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...


class Snippets:
    def CreateDynamicMethod(self, methodName: str, returnType: Type, parameterTypes: Set(Type), isDebuggable: bool) -> DynamicILGen: ...
    def DefineDelegate(self, name: str, returnType: Type, argTypes: Set(Type)) -> Type: ...
    def DefineDelegateType(self, name: str) -> TypeBuilder: ...
    def DefinePublicType(self, name: str, parent: Type) -> TypeBuilder: ...
    def DefineType(self, name: str, parent: Type, preserveName: bool, emitDebugSymbols: bool) -> TypeGen: ...
    @property
    def SaveSnippets(self) -> bool: ...
    @property
    def SnippetsDirectory(self) -> str: ...
    def IsSnippetsAssembly(self, asm: Assembly) -> bool: ...
    def SaveAndVerifyAssemblies() -> None: ...
    def SetSaveAssemblies(enable: bool, directory: str) -> None: ...


class TypeGen:
    def __init__(self, myAssembly: AssemblyGen, myType: TypeBuilder): ...
    @overload
    def AddStaticField(self, fieldType: Type, name: str) -> FieldBuilder: ...
    @overload
    def AddStaticField(self, fieldType: Type, attributes: FieldAttributes, name: str) -> FieldBuilder: ...
    def DefineExplicitInterfaceImplementation(self, baseMethod: MethodInfo) -> ILGen: ...
    def DefineMethodOverride(self, baseMethod: MethodInfo) -> ILGen: ...
    def FinishType(self) -> Type: ...
    @property
    def TypeBuilder(self) -> TypeBuilder: ...
    @property
    def TypeInitializer(self) -> ILGen: ...
    def ToString(self) -> str: ...
