__all__ = ['Calls']
from typing import Tuple, Set, Iterable, List


class ActionBinder:
    def CanConvertFrom(self, fromType: Type, toType: Type, toNotNullable: bool, level: NarrowingLevel) -> bool: ...
    def Convert(self, obj: Object, toType: Type) -> Object: ...
    def ConvertExpression(self, expr: Expression, toType: Type, kind: ConversionResultKind, resolverFactory: OverloadResolverFactory) -> Expression: ...
    @property
    def Manager(self) -> ScriptDomainManager: ...
    @property
    def PrivateBinding(self) -> bool: ...
    def GetAllExtensionMembers(self, type: Type, name: str) -> MemberGroup: ...
    def GetExtensionMembers(self, declaringType: Type, name: str) -> MemberGroup: ...
    def GetExtensionTypes(self, t: Type) -> List[Type]: ...
    def GetMember(self, action: MemberRequestKind, type: Type, name: str) -> MemberGroup: ...
    def GetObjectTypeName(self, arg: Object) -> str: ...
    def GetTypeName(self, t: Type) -> str: ...
    def IncludeExtensionMember(self, member: MemberInfo) -> bool: ...
    def MakeCallExpression(self, resolverFactory: OverloadResolverFactory, method: MethodInfo, parameters: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    def MakeContainsGenericParametersError(self, tracker: MemberTracker) -> ErrorInfo: ...
    def MakeConversionError(self, toType: Type, value: Expression) -> ErrorInfo: ...
    def MakeGenericAccessError(self, info: MemberTracker) -> ErrorInfo: ...
    def MakeMissingMemberError(self, type: Type, self: DynamicMetaObject, name: str) -> ErrorInfo: ...
    def MakeMissingMemberErrorForAssign(self, type: Type, self: DynamicMetaObject, name: str) -> ErrorInfo: ...
    def MakeMissingMemberErrorForAssignReadOnlyProperty(self, type: Type, self: DynamicMetaObject, name: str) -> ErrorInfo: ...
    def MakeMissingMemberErrorForDelete(self, type: Type, self: DynamicMetaObject, name: str) -> ErrorInfo: ...
    def MakeMissingMemberErrorInfo(self, type: Type, name: str) -> ErrorInfo: ...
    def MakeSetValueTypeFieldError(self, field: FieldTracker, instance: DynamicMetaObject, value: DynamicMetaObject) -> ErrorInfo: ...
    def MakeStaticAssignFromDerivedTypeError(self, accessingType: Type, self: DynamicMetaObject, assigning: MemberTracker, assignedValue: DynamicMetaObject, context: OverloadResolverFactory) -> ErrorInfo: ...
    @overload
    def MakeStaticPropertyInstanceAccessError(self, tracker: PropertyTracker, isAssignment: bool, parameters: List[DynamicMetaObject]) -> ErrorInfo: ...
    @overload
    def MakeStaticPropertyInstanceAccessError(self, tracker: PropertyTracker, isAssignment: bool, parameters: Set(DynamicMetaObject)) -> ErrorInfo: ...
    def PreferConvert(self, t1: Type, t2: Type) -> Candidate: ...
    def ReturnMemberTracker(self, type: Type, memberTracker: MemberTracker) -> DynamicMetaObject: ...


class Argument:
    @overload
    def __init__(self, name: str): ...
    @overload
    def __init__(self, kind: ArgumentType): ...
    @overload
    def __init__(self, kind: ArgumentType, name: str): ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Argument) -> bool: ...
    @property
    def IsSimple(self) -> bool: ...
    @property
    def Kind(self) -> ArgumentType: ...
    @property
    def Name(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: Argument, right: Argument) -> bool: ...
    def op_Inequality(left: Argument, right: Argument) -> bool: ...
    def ToString(self) -> str: ...


class ArgumentType:
    Simple = 0
    Named = 1
    List = 2
    Dictionary = 3
    Instance = 4


class BinderMappingInfo:
    @overload
    def __init__(self, binder: DynamicMetaObjectBinder, mappingInfo: List[ParameterMappingInfo]): ...
    @overload
    def __init__(self, binder: DynamicMetaObjectBinder, mappingInfos: Set(ParameterMappingInfo)): ...
    def ToString(self) -> str: ...


class BoundMemberTracker(MemberTracker):
    @overload
    def __init__(self, tracker: MemberTracker, instance: DynamicMetaObject): ...
    @overload
    def __init__(self, tracker: MemberTracker, instance: Object): ...
    @property
    def BoundTo(self) -> MemberTracker: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def Instance(self) -> DynamicMetaObject: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    @property
    def ObjectInstance(self) -> Object: ...
    def GetError(self, binder: ActionBinder, instanceType: Type) -> ErrorInfo: ...
    def GetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type) -> DynamicMetaObject: ...
    @overload
    def SetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type, value: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def SetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...


class CallSignature:
    @overload
    def __init__(self, signature: CallSignature): ...
    @overload
    def __init__(self, argumentCount: int): ...
    @overload
    def __init__(self, infos: Set(Argument)): ...
    @overload
    def __init__(self, kinds: Set(ArgumentType)): ...
    def CreateExpression(self) -> Expression: ...
    @overload
    def Equals(self, other: CallSignature) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def IsSimple(self) -> bool: ...
    def GetArgumentInfos(self) -> Set(Argument): ...
    def GetArgumentKind(self, index: int) -> ArgumentType: ...
    def GetArgumentName(self, index: int) -> str: ...
    def GetArgumentNames(self) -> Set(str): ...
    def GetHashCode(self) -> int: ...
    def GetProvidedPositionalArgumentCount(self) -> int: ...
    def HasDictionaryArgument(self) -> bool: ...
    def HasInstanceArgument(self) -> bool: ...
    def HasKeywordArgument(self) -> bool: ...
    def HasListArgument(self) -> bool: ...
    def IndexOf(self, kind: ArgumentType) -> int: ...
    def InsertArgument(self, info: Argument) -> CallSignature: ...
    def InsertArgumentAt(self, index: int, info: Argument) -> CallSignature: ...
    def op_Equality(left: CallSignature, right: CallSignature) -> bool: ...
    def op_Inequality(left: CallSignature, right: CallSignature) -> bool: ...
    def RemoveArgumentAt(self, index: int) -> CallSignature: ...
    def RemoveFirstArgument(self) -> CallSignature: ...
    def ToString(self) -> str: ...


class ComboActionRewriter:
    def __init__(self): ...


class ComboBinder:
    @overload
    def __init__(self, binders: Set(BinderMappingInfo)): ...
    @overload
    def __init__(self, binders: ICollection): ...
    @overload
    def Bind(self, target: DynamicMetaObject, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ReturnType(self) -> Type: ...
    def GetHashCode(self) -> int: ...


class ConstructorTracker(MemberTracker):
    def __init__(self, ctor: ConstructorInfo): ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    def ToString(self) -> str: ...


class ConversionResultKind:
    ImplicitCast = 0
    ExplicitCast = 1
    ImplicitTry = 2
    ExplicitTry = 3


class CustomTracker(MemberTracker):
    @property
    def MemberType(self) -> TrackerTypes: ...


class DefaultBinder(ActionBinder):
    def __init__(self): ...
    @overload
    def Call(self, signature: CallSignature, target: DynamicMetaObject, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def Call(self, signature: CallSignature, resolverFactory: OverloadResolverFactory, target: DynamicMetaObject, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def Call(self, signature: CallSignature, errorSuggestion: DynamicMetaObject, resolverFactory: OverloadResolverFactory, target: DynamicMetaObject, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def CallMethod(self, resolver: DefaultOverloadResolver, targets: List[MethodBase]) -> DynamicMetaObject: ...
    @overload
    def CallMethod(self, resolver: DefaultOverloadResolver, targets: List[MethodBase], name: str) -> DynamicMetaObject: ...
    @overload
    def CallMethod(self, resolver: DefaultOverloadResolver, targets: List[MethodBase], restrictions: BindingRestrictions) -> DynamicMetaObject: ...
    @overload
    def CallMethod(self, resolver: DefaultOverloadResolver, targets: List[MethodBase], restrictions: BindingRestrictions, name: str) -> DynamicMetaObject: ...
    @overload
    def CallMethod(self, resolver: DefaultOverloadResolver, targets: List[MethodBase], restrictions: BindingRestrictions, name: str, minLevel: NarrowingLevel, maxLevel: NarrowingLevel) -> Tuple[DynamicMetaObject, BindingTarget]: ...
    def CanConvertFrom(self, fromType: Type, toType: Type, toNotNullable: bool, level: NarrowingLevel) -> bool: ...
    @overload
    def ConvertTo(self, toType: Type, kind: ConversionResultKind, arg: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def ConvertTo(self, toType: Type, kind: ConversionResultKind, arg: DynamicMetaObject, resolverFactory: OverloadResolverFactory) -> DynamicMetaObject: ...
    @overload
    def ConvertTo(self, toType: Type, kind: ConversionResultKind, arg: DynamicMetaObject, resolverFactory: OverloadResolverFactory, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def DeleteMember(self, name: str, target: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def DeleteMember(self, name: str, target: DynamicMetaObject, resolutionFactory: OverloadResolverFactory) -> DynamicMetaObject: ...
    @overload
    def DeleteMember(self, name: str, target: DynamicMetaObject, resolutionFactory: OverloadResolverFactory, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def DoOperation(self, operation: ExpressionType, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def DoOperation(self, operation: ExpressionType, resolverFactory: OverloadResolverFactory, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    def GetCallSignatures(self, target: DynamicMetaObject) -> DynamicMetaObject: ...
    def GetDocumentation(self, target: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def GetIndex(self, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def GetIndex(self, resolverFactory: OverloadResolverFactory, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    def GetIsCallable(self, target: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def GetMember(self, name: str, target: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def GetMember(self, name: str, target: DynamicMetaObject, resolverFactory: OverloadResolverFactory) -> DynamicMetaObject: ...
    @overload
    def GetMember(self, name: str, target: DynamicMetaObject, isNoThrow: bool, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def GetMember(self, name: str, target: DynamicMetaObject, resolverFactory: OverloadResolverFactory, isNoThrow: bool, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...
    def GetMemberNames(self, target: DynamicMetaObject) -> DynamicMetaObject: ...
    def GetMemberType(self, members: MemberGroup) -> Tuple[TrackerTypes, Expression]: ...
    def GetMethod(self, type: Type, name: str) -> MethodInfo: ...
    def GetTryConvertReturnValue(type: Type) -> Expression: ...
    @overload
    def MakeError(error: ErrorInfo, type: Type) -> DynamicMetaObject: ...
    @overload
    def MakeError(error: ErrorInfo, restrictions: BindingRestrictions, type: Type) -> DynamicMetaObject: ...
    def MakeEventValidation(self, members: MemberGroup, eventObject: DynamicMetaObject, value: DynamicMetaObject, resolverFactory: OverloadResolverFactory) -> ErrorInfo: ...
    def MakeNonPublicMemberGetError(self, resolverFactory: OverloadResolverFactory, member: MemberTracker, type: Type, instance: DynamicMetaObject) -> ErrorInfo: ...
    def MakeReadOnlyMemberError(self, type: Type, name: str) -> ErrorInfo: ...
    def MakeUndeletableMemberError(self, type: Type, name: str) -> ErrorInfo: ...
    def PreferConvert(self, t1: Type, t2: Type) -> Candidate: ...
    @overload
    def SetIndex(self, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def SetIndex(self, resolverFactory: OverloadResolverFactory, args: Set(DynamicMetaObject)) -> DynamicMetaObject: ...
    @overload
    def SetMember(self, name: str, target: DynamicMetaObject, value: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def SetMember(self, name: str, target: DynamicMetaObject, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def SetMember(self, name: str, target: DynamicMetaObject, value: DynamicMetaObject, resolverFactory: OverloadResolverFactory) -> DynamicMetaObject: ...
    @overload
    def SetMember(self, name: str, target: DynamicMetaObject, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject, resolverFactory: OverloadResolverFactory) -> DynamicMetaObject: ...


class DefaultOverloadResolver(OverloadResolver):
    @overload
    def __init__(self, binder: ActionBinder, args: List[DynamicMetaObject], signature: CallSignature): ...
    @overload
    def __init__(self, binder: ActionBinder, instance: DynamicMetaObject, args: List[DynamicMetaObject], signature: CallSignature): ...
    @overload
    def __init__(self, binder: ActionBinder, args: List[DynamicMetaObject], signature: CallSignature, callType: CallTypes): ...
    @property
    def Arguments(self) -> List[DynamicMetaObject]: ...
    @property
    def CallType(self) -> CallTypes: ...
    @property
    def Factory() -> OverloadResolverFactory: ...
    @property
    def Signature(self) -> CallSignature: ...
    def MakeInvalidParametersError(self, target: BindingTarget) -> ErrorInfo: ...


class DynamicSiteHelpers:
    def GetStandardDelegateType(types: Set(Type)) -> Type: ...
    def IsInvisibleDlrStackFrame(mb: MethodBase) -> bool: ...
    def MakeCallSiteDelegate(types: Set(Type)) -> Type: ...


class ErrorInfo:
    def FromException(exceptionValue: Expression) -> ErrorInfo: ...
    def FromValue(resultValue: Expression) -> ErrorInfo: ...
    def FromValueNoError(resultValue: Expression) -> ErrorInfo: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def Kind(self) -> ErrorInfoKind: ...


class ErrorInfoKind:
    Exception = 0
    Error = 1
    Success = 2


class ErrorMetaObject:
    def __init__(self, body: Expression, restrictions: BindingRestrictions): ...


class EventTracker(MemberTracker):
    def AddHandler(self, target: Object, handler: Object, delegateCreator: DynamicDelegateCreator) -> None: ...
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def Event(self) -> EventInfo: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    def GetCallableAddMethod(self) -> MethodInfo: ...
    def GetCallableRemoveMethod(self) -> MethodInfo: ...
    def RemoveHandler(self, target: Object, handler: Object, objectComparer: IEqualityComparer) -> None: ...
    def ToString(self) -> str: ...


class ExtensionBinaryOperationBinder:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ExtensionOperation(self) -> str: ...
    def GetHashCode(self) -> int: ...


class ExtensionMethodTracker(MethodTracker):
    @property
    def DeclaringType(self) -> Type: ...


class ExtensionPropertyTracker(PropertyTracker):
    def __init__(self, name: str, getter: MethodInfo, setter: MethodInfo, deleter: MethodInfo, declaringType: Type): ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def PropertyType(self) -> Type: ...
    @overload
    def GetDeleteMethod(self) -> MethodInfo: ...
    @overload
    def GetDeleteMethod(self, privateMembers: bool) -> MethodInfo: ...
    @overload
    def GetGetMethod(self) -> MethodInfo: ...
    @overload
    def GetGetMethod(self, privateMembers: bool) -> MethodInfo: ...
    def GetIndexParameters(self) -> Set(ParameterInfo): ...
    @overload
    def GetSetMethod(self) -> MethodInfo: ...
    @overload
    def GetSetMethod(self, privateMembers: bool) -> MethodInfo: ...


class ExtensionUnaryOperationBinder:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ExtensionOperation(self) -> str: ...
    def GetHashCode(self) -> int: ...


class FieldTracker(MemberTracker):
    def __init__(self, field: FieldInfo): ...
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def Field(self) -> FieldInfo: ...
    @property
    def FieldType(self) -> Type: ...
    @property
    def IsInitOnly(self) -> bool: ...
    @property
    def IsLiteral(self) -> bool: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    def GetError(self, binder: ActionBinder, instanceType: Type) -> ErrorInfo: ...
    def GetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, type: Type) -> DynamicMetaObject: ...
    def ToString(self) -> str: ...


class ILightExceptionBinder:
    @property
    def SupportsLightThrow(self) -> bool: ...
    def GetLightExceptionBinder(self) -> CallSiteBinder: ...


class Interceptor:
    @overload
    def Intercept(expression: Expression) -> Expression: ...
    @overload
    def Intercept(lambda: LambdaExpression) -> LambdaExpression: ...


class MemberGroup:
    @overload
    def __init__(self, members: Set(MemberTracker)): ...
    @overload
    def __init__(self, members: Set(MemberInfo)): ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self, index: int) -> MemberTracker: ...
    def GetEnumerator(self) -> IEnumerator: ...


class MemberRequestKind:
    #None = 0
    Get = 1
    Set = 2
    Delete = 3
    Invoke = 4
    InvokeMember = 5
    Convert = 6
    Operation = 7


class MemberTracker:
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @overload
    def FromMemberInfo(member: MemberInfo) -> MemberTracker: ...
    @overload
    def FromMemberInfo(member: MemberInfo, extending: Type) -> MemberTracker: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    def GetBoundError(self, binder: ActionBinder, instance: DynamicMetaObject, instanceType: Type) -> ErrorInfo: ...
    def GetError(self, binder: ActionBinder, instanceType: Type) -> ErrorInfo: ...
    def GetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type) -> DynamicMetaObject: ...
    @overload
    def SetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type, value: DynamicMetaObject) -> DynamicMetaObject: ...
    @overload
    def SetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type, value: DynamicMetaObject, errorSuggestion: DynamicMetaObject) -> DynamicMetaObject: ...


class MethodGroup(MemberTracker):
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @property
    def ContainsInstance(self) -> bool: ...
    @property
    def ContainsStatic(self) -> bool: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Methods(self) -> List[MethodTracker]: ...
    @property
    def Name(self) -> str: ...
    def GetMethodBases(self) -> Set(MethodBase): ...
    def MakeGenericMethod(self, types: Set(Type)) -> MethodGroup: ...


class MethodTracker(MemberTracker):
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Name(self) -> str: ...
    def ToString(self) -> str: ...


class NamespaceTracker(MemberTracker):
    def ContainsKey(self, name: str) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def Id(self) -> int: ...
    @property
    def Item(self, name: str) -> Object: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    @property
    def PackageAssemblies(self) -> List[Assembly]: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetMemberNames(self) -> List[str]: ...
    def ToString(self) -> str: ...
    @overload
    def TryGetValue(self, name: str) -> Tuple[bool, MemberTracker]: ...
    @overload
    def TryGetValue(self, name: str) -> Tuple[bool, Object]: ...


class NestedTypeTracker(TypeTracker):
    def __init__(self, type: Type): ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsGenericType(self) -> bool: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    @property
    def Type(self) -> Type: ...
    def ToString(self) -> str: ...


class NoSideEffectsAttribute:
    def __init__(self): ...


class OperationMetaObject:
    @overload
    def __init__(self, expression: Expression, restrictions: BindingRestrictions): ...
    @overload
    def __init__(self, expression: Expression, restrictions: BindingRestrictions, value: Object): ...


class ParameterMappingInfo:
    def Action(index: int) -> ParameterMappingInfo: ...
    def Equals(self, obj: Object) -> bool: ...
    def Fixed(e: ConstantExpression) -> ParameterMappingInfo: ...
    @property
    def ActionIndex(self) -> int: ...
    @property
    def Constant(self) -> ConstantExpression: ...
    @property
    def IsAction(self) -> bool: ...
    @property
    def IsConstant(self) -> bool: ...
    @property
    def IsParameter(self) -> bool: ...
    @property
    def ParameterIndex(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def Parameter(index: int) -> ParameterMappingInfo: ...
    def ToString(self) -> str: ...


class PropertyTracker(MemberTracker):
    def BindToInstance(self, instance: DynamicMetaObject) -> MemberTracker: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def PropertyType(self) -> Type: ...
    def GetBoundError(self, binder: ActionBinder, instance: DynamicMetaObject, instanceType: Type) -> ErrorInfo: ...
    @overload
    def GetDeleteMethod(self) -> MethodInfo: ...
    @overload
    def GetDeleteMethod(self, privateMembers: bool) -> MethodInfo: ...
    def GetError(self, binder: ActionBinder, instanceType: Type) -> ErrorInfo: ...
    @overload
    def GetGetMethod(self) -> MethodInfo: ...
    @overload
    def GetGetMethod(self, privateMembers: bool) -> MethodInfo: ...
    def GetIndexParameters(self) -> Set(ParameterInfo): ...
    @overload
    def GetSetMethod(self) -> MethodInfo: ...
    @overload
    def GetSetMethod(self, privateMembers: bool) -> MethodInfo: ...
    def GetValue(self, resolverFactory: OverloadResolverFactory, binder: ActionBinder, instanceType: Type) -> DynamicMetaObject: ...


class ReflectedPropertyTracker(PropertyTracker):
    def __init__(self, property: PropertyInfo): ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def Property(self) -> PropertyInfo: ...
    @property
    def PropertyType(self) -> Type: ...
    @overload
    def GetDeleteMethod(self) -> MethodInfo: ...
    @overload
    def GetDeleteMethod(self, privateMembers: bool) -> MethodInfo: ...
    @overload
    def GetGetMethod(self) -> MethodInfo: ...
    @overload
    def GetGetMethod(self, privateMembers: bool) -> MethodInfo: ...
    def GetIndexParameters(self) -> Set(ParameterInfo): ...
    @overload
    def GetSetMethod(self) -> MethodInfo: ...
    @overload
    def GetSetMethod(self, privateMembers: bool) -> MethodInfo: ...
    def ToString(self) -> str: ...


class TopNamespaceTracker(NamespaceTracker):
    def __init__(self, manager: ScriptDomainManager): ...
    @property
    def DomainManager(self) -> ScriptDomainManager: ...
    def LoadAssembly(self, assem: Assembly) -> bool: ...
    def PublishComTypes(interopAssembly: Assembly) -> None: ...
    def TryGetPackage(self, name: str) -> NamespaceTracker: ...
    def TryGetPackageAny(self, name: str) -> MemberTracker: ...
    def TryGetPackageLazy(self, name: str) -> MemberTracker: ...


class TrackerTypes:
    #None = 0
    Constructor = 1
    Event = 2
    Field = 4
    Method = 8
    Property = 16
    Type = 32
    Namespace = 64
    MethodGroup = 128
    TypeGroup = 256
    Custom = 512
    Bound = 1024
    All = 1535


class TypeGroup(TypeTracker):
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def IsGenericType(self) -> bool: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def MemberType(self) -> TrackerTypes: ...
    @property
    def Name(self) -> str: ...
    @property
    def Type(self) -> Type: ...
    @property
    def Types(self) -> Iterable[Type]: ...
    @property
    def TypesByArity(self) -> IDictionary: ...
    def GetMemberNames(self) -> List[str]: ...
    def GetNonGenericType(self) -> Type: ...
    def GetTypeForArity(self, arity: int) -> TypeTracker: ...
    def ToString(self) -> str: ...
    def TryGetNonGenericType(self) -> Tuple[bool, Type]: ...
    def UpdateTypeEntity(existingTypeEntity: TypeTracker, newType: TypeTracker) -> TypeTracker: ...


class TypeTracker(MemberTracker):
    @property
    def IsGenericType(self) -> bool: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def Type(self) -> Type: ...
    def GetMemberNames(self) -> List[str]: ...
    def GetTypeTracker(type: Type) -> TypeTracker: ...
    def op_Explicit(tracker: TypeTracker) -> Type: ...
