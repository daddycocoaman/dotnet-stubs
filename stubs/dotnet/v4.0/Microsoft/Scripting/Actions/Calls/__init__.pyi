from typing import Tuple, Set, Iterable, List


class ActualArguments:
    def __init__(self, args: List[DynamicMetaObject], namedArgs: List[DynamicMetaObject], argNames: List[str], hiddenCount: int, collapsedCount: int, firstSplattedArg: int, splatIndex: int): ...
    @property
    def ArgNames(self) -> List[str]: ...
    @property
    def Arguments(self) -> List[DynamicMetaObject]: ...
    @property
    def CollapsedCount(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def FirstSplattedArg(self) -> int: ...
    @property
    def HiddenCount(self) -> int: ...
    @property
    def Item(self, index: int) -> DynamicMetaObject: ...
    @property
    def NamedArguments(self) -> List[DynamicMetaObject]: ...
    @property
    def SplatIndex(self) -> int: ...
    @property
    def VisibleCount(self) -> int: ...


class ApplicableCandidate:
    def GetParameter(self, argumentIndex: int) -> ParameterWrapper: ...
    def ToString(self) -> str: ...


class ArgBuilder:
    def Clone(self, newType: ParameterInfo) -> ArgBuilder: ...
    @property
    def ConsumedArgumentCount(self) -> int: ...
    @property
    def ParameterInfo(self) -> ParameterInfo: ...
    @property
    def Priority(self) -> int: ...
    @property
    def Type(self) -> Type: ...


class ArgumentBinding:
    def ArgumentToParameter(self, argumentIndex: int) -> int: ...
    @property
    def PositionalArgCount(self) -> int: ...


class BindingResult:
    Success = 0
    AmbiguousMatch = 1
    IncorrectArgumentCount = 2
    CallFailure = 3
    InvalidArguments = 4
    NoCallableMethod = 5


class BindingTarget:
    @property
    def ActualArgumentCount(self) -> int: ...
    @property
    def AmbiguousMatches(self) -> Iterable[MethodCandidate]: ...
    @property
    def CallFailures(self) -> ICollection: ...
    @property
    def ExpectedArgumentCount(self) -> List[int]: ...
    @property
    def Method(self) -> MethodBase: ...
    @property
    def MethodCandidate(self) -> MethodCandidate: ...
    @property
    def Name(self) -> str: ...
    @property
    def NarrowingLevel(self) -> NarrowingLevel: ...
    @property
    def Overload(self) -> OverloadInfo: ...
    @property
    def RestrictedArguments(self) -> RestrictedArguments: ...
    @property
    def Result(self) -> BindingResult: ...
    @property
    def ReturnType(self) -> Type: ...
    @property
    def Success(self) -> bool: ...
    def MakeExpression(self) -> Expression: ...


class CallFailure:
    @property
    def Candidate(self) -> MethodCandidate: ...
    @property
    def ConversionResults(self) -> List[ConversionResult]: ...
    @property
    def KeywordArguments(self) -> List[str]: ...
    @property
    def PositionalArguments(self) -> List[int]: ...
    @property
    def Reason(self) -> CallFailureReason: ...


class CallFailureReason:
    #None = 0
    ConversionFailure = 1
    UnassignableKeyword = 2
    DuplicateKeyword = 3
    TypeInference = 4


class Candidate:
    Equivalent = 0
    One = 1
    Ambiguous = 2
    Two = -1


class ConversionResult:
    @property
    def Arg(self) -> Object: ...
    @property
    def ArgType(self) -> Type: ...
    @property
    def Failed(self) -> bool: ...
    @property
    def To(self) -> Type: ...
    def GetArgumentTypeName(self, binder: ActionBinder) -> str: ...


class IInferableInvokable:
    def GetInferredType(self, delegateType: Type, parameterType: Type) -> InferenceResult: ...


class InferenceResult:
    def __init__(self, type: Type, restrictions: BindingRestrictions): ...
    @property
    def Restrictions(self) -> BindingRestrictions: ...
    @property
    def Type(self) -> Type: ...


class InstanceBuilder:
    def __init__(self, index: int): ...
    @property
    def ConsumedArgumentCount(self) -> int: ...
    @property
    def HasValue(self) -> bool: ...


class MethodCandidate:
    @property
    def Binder(self) -> ActionBinder: ...
    @property
    def HasParamsArray(self) -> bool: ...
    @property
    def HasParamsDictionary(self) -> bool: ...
    @property
    def Method(self) -> MethodBase: ...
    @property
    def Overload(self) -> OverloadInfo: ...
    @property
    def ParamsArrayIndex(self) -> int: ...
    @property
    def Resolver(self) -> OverloadResolver: ...
    @property
    def ReturnType(self) -> Type: ...
    def GetParameters(self) -> List[ParameterWrapper]: ...
    def GetParameterTypes(self) -> Set(Type): ...
    def GetVisibleParameterCount(self) -> int: ...
    def ToString(self) -> str: ...


class NarrowingLevel:
    #None = 0
    One = 1
    Two = 2
    Three = 3
    All = 4


class OverloadInfo:
    @property
    def Attributes(self) -> MethodAttributes: ...
    @property
    def CallingConvention(self) -> CallingConventions: ...
    @property
    def ContainsGenericParameters(self) -> bool: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def GenericArguments(self) -> List[Type]: ...
    @property
    def IsAssembly(self) -> bool: ...
    @property
    def IsConstructor(self) -> bool: ...
    @property
    def IsExtension(self) -> bool: ...
    @property
    def IsFamily(self) -> bool: ...
    @property
    def IsFamilyAndAssembly(self) -> bool: ...
    @property
    def IsFamilyOrAssembly(self) -> bool: ...
    @property
    def IsFinal(self) -> bool: ...
    @property
    def IsGenericMethod(self) -> bool: ...
    @property
    def IsGenericMethodDefinition(self) -> bool: ...
    @property
    def IsInstanceFactory(self) -> bool: ...
    @property
    def IsPrivate(self) -> bool: ...
    @property
    def IsProtected(self) -> bool: ...
    @property
    def IsPublic(self) -> bool: ...
    @property
    def IsSpecialName(self) -> bool: ...
    @property
    def IsStatic(self) -> bool: ...
    @property
    def IsVariadic(self) -> bool: ...
    @property
    def IsVirtual(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def ParameterCount(self) -> int: ...
    @property
    def Parameters(self) -> List[ParameterInfo]: ...
    @property
    def ReflectionInfo(self) -> MethodBase: ...
    @property
    def ReturnParameter(self) -> ParameterInfo: ...
    @property
    def ReturnType(self) -> Type: ...
    def IsParamArray(self, parameterIndex: int) -> bool: ...
    def IsParamDictionary(self, parameterIndex: int) -> bool: ...
    def MakeGenericMethod(self, genericArguments: Set(Type)) -> OverloadInfo: ...
    def ProhibitsNull(self, parameterIndex: int) -> bool: ...
    def ProhibitsNullItems(self, parameterIndex: int) -> bool: ...


class OverloadResolver:
    @overload
    def CanConvertFrom(self, parameter1: ParameterWrapper, parameter2: ParameterWrapper) -> bool: ...
    @overload
    def CanConvertFrom(self, fromType: Type, fromArgument: DynamicMetaObject, toParameter: ParameterWrapper, level: NarrowingLevel) -> bool: ...
    def Convert(self, metaObject: DynamicMetaObject, restrictedType: Type, info: ParameterInfo, toType: Type) -> Expression: ...
    @property
    def Binder(self) -> ActionBinder: ...
    @property
    def MaxAccessedCollapsedArg(self) -> int: ...
    def GetActualArguments(self) -> ActualArguments: ...
    def GetCollapsedArgsCondition(self) -> Expression: ...
    def GetDynamicConversion(self, value: Expression, type: Type) -> Expression: ...
    def GetGenericInferenceType(self, dynamicObject: DynamicMetaObject) -> Type: ...
    def MakeInvalidParametersError(self, target: BindingTarget) -> ErrorInfo: ...
    def ParametersEquivalent(self, parameter1: ParameterWrapper, parameter2: ParameterWrapper) -> bool: ...
    def PreferConvert(self, t1: Type, t2: Type) -> Candidate: ...
    @overload
    def ResolveOverload(self, methodName: str, methods: List[OverloadInfo], minLevel: NarrowingLevel, maxLevel: NarrowingLevel) -> BindingTarget: ...
    @overload
    def ResolveOverload(self, methodName: str, methods: List[MethodBase], minLevel: NarrowingLevel, maxLevel: NarrowingLevel) -> BindingTarget: ...
    def SelectBestConversionFor(self, arg: DynamicMetaObject, candidateOne: ParameterWrapper, candidateTwo: ParameterWrapper, level: NarrowingLevel) -> Candidate: ...
    def ToString(self) -> str: ...


class OverloadResolverFactory:
    def CreateOverloadResolver(self, args: List[DynamicMetaObject], signature: CallSignature, callType: CallTypes) -> DefaultOverloadResolver: ...


class ParameterBindingFlags:
    #None = 0
    ProhibitNull = 1
    ProhibitNullItems = 2
    IsParamArray = 4
    IsParamDictionary = 8
    IsHidden = 16


class ParameterMapping:
    def AddBuilder(self, builder: ArgBuilder) -> None: ...
    def AddInstanceBuilder(self, builder: InstanceBuilder) -> None: ...
    def AddParameter(self, parameter: ParameterWrapper) -> None: ...
    @property
    def ArgIndex(self) -> int: ...
    @property
    def Method(self) -> MethodBase: ...
    @property
    def Overload(self) -> OverloadInfo: ...
    @property
    def ParameterInfos(self) -> Set(ParameterInfo): ...
    def MapParameter(self, pi: ParameterInfo) -> None: ...


class ParameterWrapper:
    @overload
    def __init__(self, type: Type, name: str, prohibitNull: bool): ...
    @overload
    def __init__(self, info: ParameterInfo, type: Type, name: str, flags: ParameterBindingFlags): ...
    @overload
    def __init__(self, info: ParameterInfo, type: Type, name: str, prohibitNull: bool, isParams: bool, isParamsDict: bool, isHidden: bool): ...
    def Clone(self, name: str) -> ParameterWrapper: ...
    @property
    def Flags(self) -> ParameterBindingFlags: ...
    @property
    def IsByRef(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsParamsArray(self) -> bool: ...
    @property
    def IsParamsDict(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def ParameterInfo(self) -> ParameterInfo: ...
    @property
    def ProhibitNull(self) -> bool: ...
    @property
    def ProhibitNullItems(self) -> bool: ...
    @property
    def Type(self) -> Type: ...


class ReflectionOverloadInfo(OverloadInfo):
    def __init__(self, method: MethodBase): ...
    def CreateArray(methods: Set(MethodBase)) -> Set(OverloadInfo): ...
    @property
    def Attributes(self) -> MethodAttributes: ...
    @property
    def CallingConvention(self) -> CallingConventions: ...
    @property
    def ContainsGenericParameters(self) -> bool: ...
    @property
    def DeclaringType(self) -> Type: ...
    @property
    def GenericArguments(self) -> List[Type]: ...
    @property
    def IsConstructor(self) -> bool: ...
    @property
    def IsExtension(self) -> bool: ...
    @property
    def IsGenericMethod(self) -> bool: ...
    @property
    def IsGenericMethodDefinition(self) -> bool: ...
    @property
    def IsInstanceFactory(self) -> bool: ...
    @property
    def IsVariadic(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def Parameters(self) -> List[ParameterInfo]: ...
    @property
    def ReflectionInfo(self) -> MethodBase: ...
    @property
    def ReturnParameter(self) -> ParameterInfo: ...
    @property
    def ReturnType(self) -> Type: ...
    def MakeGenericMethod(self, genericArguments: Set(Type)) -> OverloadInfo: ...


class RestrictedArguments:
    def __init__(self, objects: Set(DynamicMetaObject), types: Set(Type), hasUntypedRestrictions: bool): ...
    @property
    def HasUntypedRestrictions(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    def GetAllRestrictions(self) -> BindingRestrictions: ...
    def GetObject(self, i: int) -> DynamicMetaObject: ...
    def GetObjects(self) -> List[DynamicMetaObject]: ...
    @overload
    def GetType(self, i: int) -> Type: ...
    def GetTypes(self) -> List[Type]: ...


class SimpleArgBuilder(ArgBuilder):
    @overload
    def __init__(self, info: ParameterInfo, index: int): ...
    @overload
    def __init__(self, parameterType: Type, index: int, isParams: bool, isParamsDict: bool): ...
    @overload
    def __init__(self, info: ParameterInfo, parameterType: Type, index: int, isParams: bool, isParamsDict: bool): ...
    def Clone(self, newType: ParameterInfo) -> ArgBuilder: ...
    @property
    def ConsumedArgumentCount(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsParamsArray(self) -> bool: ...
    @property
    def IsParamsDict(self) -> bool: ...
    @property
    def Priority(self) -> int: ...
    @property
    def Type(self) -> Type: ...


class TypeInferer:
    def GetInferedType(genericParameter: Type, parameterType: Type, inputType: Type, argType: Type, binding: Dictionary) -> Type: ...
