from typing import Tuple, Set, Iterable, List


class IOControlCode:
    EnableCircularQueuing = 671088642
    Flush = 671088644
    AddressListChange = 671088663
    DataToRead = 1074030207
    OobDataRead = 1074033415
    GetBroadcastAddress = 1207959557
    AddressListQuery = 1207959574
    QueryTargetPnpHandle = 1207959576
    AsyncIO = 2147772029
    NonBlockingIO = 2147772030
    AssociateHandle = 2281701377
    MultipointLoopback = 2281701385
    MulticastScope = 2281701386
    SetQos = 2281701387
    SetGroupQos = 2281701388
    RoutingInterfaceChange = 2281701397
    NamespaceChange = 2281701401
    ReceiveAll = 2550136833
    ReceiveAllMulticast = 2550136834
    ReceiveAllIgmpMulticast = 2550136835
    KeepAliveValues = 2550136836
    AbsorbRouterAlert = 2550136837
    UnicastInterface = 2550136838
    LimitBroadcasts = 2550136839
    BindToInterface = 2550136840
    MulticastInterface = 2550136841
    AddMulticastGroupOnInterface = 2550136842
    DeleteMulticastGroupFromInterface = 2550136843
    GetExtensionFunctionPointer = 3355443206
    GetQos = 3355443207
    GetGroupQos = 3355443208
    TranslateHandle = 3355443213
    RoutingInterfaceQuery = 3355443220
    AddressListSort = 3355443225


class IPPacketInformation(ValueType):
    def Equals(self, comparand: Object) -> bool: ...
    @property
    def Address(self) -> IPAddress: ...
    @property
    def Interface(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(packetInformation1: IPPacketInformation, packetInformation2: IPPacketInformation) -> bool: ...
    def op_Inequality(packetInformation1: IPPacketInformation, packetInformation2: IPPacketInformation) -> bool: ...


class IPProtectionLevel:
    Unrestricted = 10
    EdgeRestricted = 20
    Restricted = 30
    Unspecified = -1


class IPv6MulticastOption(Object):
    @overload
    def __init__(self, group: IPAddress): ...
    @overload
    def __init__(self, group: IPAddress, ifindex: Int64): ...
    @property
    def Group(self) -> IPAddress: ...
    @property
    def InterfaceIndex(self) -> Int64: ...
    @Group.setter
    def Group(self, value: IPAddress) -> None: ...
    @InterfaceIndex.setter
    def InterfaceIndex(self, value: Int64) -> None: ...


class LingerOption(Object):
    def __init__(self, enable: bool, seconds: int): ...
    @property
    def Enabled(self) -> bool: ...
    @property
    def LingerTime(self) -> int: ...
    @Enabled.setter
    def Enabled(self, value: bool) -> None: ...
    @LingerTime.setter
    def LingerTime(self, value: int) -> None: ...


class MulticastOption(Object):
    @overload
    def __init__(self, group: IPAddress): ...
    @overload
    def __init__(self, group: IPAddress, interfaceIndex: int): ...
    @overload
    def __init__(self, group: IPAddress, mcint: IPAddress): ...
    @property
    def Group(self) -> IPAddress: ...
    @property
    def InterfaceIndex(self) -> int: ...
    @property
    def LocalAddress(self) -> IPAddress: ...
    @Group.setter
    def Group(self, value: IPAddress) -> None: ...
    @InterfaceIndex.setter
    def InterfaceIndex(self, value: int) -> None: ...
    @LocalAddress.setter
    def LocalAddress(self, value: IPAddress) -> None: ...


class NetworkStream(Stream):
    @overload
    def __init__(self, socket: Socket): ...
    @overload
    def __init__(self, socket: Socket, ownsSocket: bool): ...
    @overload
    def __init__(self, socket: Socket, access: FileAccess): ...
    @overload
    def __init__(self, socket: Socket, access: FileAccess, ownsSocket: bool): ...
    def BeginRead(self, buffer: Set(Byte), offset: int, count: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Set(Byte), offset: int, count: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def Close(self, timeout: int) -> None: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    @overload
    def FlushAsync(self, cancellationToken: CancellationToken) -> Task: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def DataAvailable(self) -> bool: ...
    @property
    def Length(self) -> Int64: ...
    @property
    def Position(self) -> Int64: ...
    @property
    def ReadTimeout(self) -> int: ...
    @property
    def Socket(self) -> Socket: ...
    @property
    def WriteTimeout(self) -> int: ...
    @overload
    def Read(self, buffer: Span) -> int: ...
    @overload
    def Read(self, buffer: Set(Byte), offset: int, count: int) -> int: ...
    @overload
    def ReadAsync(self, buffer: Memory, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ReadAsync(self, buffer: Set(Byte), offset: int, count: int, cancellationToken: CancellationToken) -> Task: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: Int64, origin: SeekOrigin) -> Int64: ...
    @Position.setter
    def Position(self, value: Int64) -> None: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> None: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> None: ...
    def SetLength(self, value: Int64) -> None: ...
    @overload
    def Write(self, buffer: ReadOnlySpan) -> None: ...
    @overload
    def Write(self, buffer: Set(Byte), offset: int, count: int) -> None: ...
    @overload
    def WriteAsync(self, buffer: ReadOnlyMemory, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def WriteAsync(self, buffer: Set(Byte), offset: int, count: int, cancellationToken: CancellationToken) -> Task: ...
    def WriteByte(self, value: Byte) -> None: ...


class ProtocolFamily:
    Unspecified = 0
    Unix = 1
    InterNetwork = 2
    ImpLink = 3
    Pup = 4
    Chaos = 5
    NS = 6
    Ipx = 6
    Osi = 7
    Iso = 7
    Ecma = 8
    DataKit = 9
    Ccitt = 10
    Sna = 11
    DecNet = 12
    DataLink = 13
    Lat = 14
    HyperChannel = 15
    AppleTalk = 16
    NetBios = 17
    VoiceView = 18
    FireFox = 19
    Banyan = 21
    Atm = 22
    InterNetworkV6 = 23
    Cluster = 24
    Ieee12844 = 25
    Irda = 26
    NetworkDesigners = 28
    Max = 29
    Packet = 65536
    ControllerAreaNetwork = 65537
    Unknown = -1


class ProtocolType:
    IPv6HopByHopOptions = 0
    IP = 0
    Unspecified = 0
    Icmp = 1
    Igmp = 2
    Ggp = 3
    IPv4 = 4
    Tcp = 6
    Pup = 12
    Udp = 17
    Idp = 22
    IPv6 = 41
    IPv6RoutingHeader = 43
    IPv6FragmentHeader = 44
    IPSecEncapsulatingSecurityPayload = 50
    IPSecAuthenticationHeader = 51
    IcmpV6 = 58
    IPv6NoNextHeader = 59
    IPv6DestinationOptions = 60
    ND = 77
    Raw = 255
    Ipx = 1000
    Spx = 1256
    SpxII = 1257
    Unknown = -1


class SafeSocketHandle:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, preexistingHandle: IntPtr, ownsHandle: bool): ...
    @property
    def IsInvalid(self) -> bool: ...


class SelectMode:
    SelectRead = 0
    SelectWrite = 1
    SelectError = 2


class SendPacketsElement(Object):
    @overload
    def __init__(self, filepath: str): ...
    @overload
    def __init__(self, fileStream: FileStream): ...
    @overload
    def __init__(self, buffer: Set(Byte)): ...
    @overload
    def __init__(self, buffer: ReadOnlyMemory): ...
    @overload
    def __init__(self, buffer: ReadOnlyMemory, endOfPacket: bool): ...
    @overload
    def __init__(self, filepath: str, offset: int, count: int): ...
    @overload
    def __init__(self, filepath: str, offset: Int64, count: int): ...
    @overload
    def __init__(self, fileStream: FileStream, offset: Int64, count: int): ...
    @overload
    def __init__(self, buffer: Set(Byte), offset: int, count: int): ...
    @overload
    def __init__(self, filepath: str, offset: int, count: int, endOfPacket: bool): ...
    @overload
    def __init__(self, filepath: str, offset: Int64, count: int, endOfPacket: bool): ...
    @overload
    def __init__(self, fileStream: FileStream, offset: Int64, count: int, endOfPacket: bool): ...
    @overload
    def __init__(self, buffer: Set(Byte), offset: int, count: int, endOfPacket: bool): ...
    @property
    def Buffer(self) -> Set(Byte): ...
    @property
    def Count(self) -> int: ...
    @property
    def EndOfPacket(self) -> bool: ...
    @property
    def FilePath(self) -> str: ...
    @property
    def FileStream(self) -> FileStream: ...
    @property
    def MemoryBuffer(self) -> Nullable: ...
    @property
    def Offset(self) -> int: ...
    @property
    def OffsetLong(self) -> Int64: ...


class Socket(Object):
    @overload
    def __init__(self, socketInformation: SocketInformation): ...
    @overload
    def __init__(self, handle: SafeSocketHandle): ...
    @overload
    def __init__(self, socketType: SocketType, protocolType: ProtocolType): ...
    @overload
    def __init__(self, addressFamily: AddressFamily, socketType: SocketType, protocolType: ProtocolType): ...
    def Accept(self) -> Socket: ...
    @overload
    def AcceptAsync(self) -> Task: ...
    @overload
    def AcceptAsync(self, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def AcceptAsync(self, acceptSocket: Socket) -> Task: ...
    @overload
    def AcceptAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def AcceptAsync(self, acceptSocket: Socket, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def BeginAccept(self, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginAccept(self, receiveSize: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginAccept(self, acceptSocket: Socket, receiveSize: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, remoteEP: EndPoint, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, address: IPAddress, port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, addresses: Set(IPAddress), port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, host: str, port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def BeginDisconnect(self, reuseSocket: bool, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginReceive(self, buffers: List[Byte], socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginReceive(self, buffers: List[Byte], socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, SocketError]: ...
    @overload
    def BeginReceive(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginReceive(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, SocketError]: ...
    def BeginReceiveFrom(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, EndPoint]: ...
    def BeginReceiveMessageFrom(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, EndPoint]: ...
    @overload
    def BeginSend(self, buffers: List[Byte], socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSend(self, buffers: List[Byte], socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, SocketError]: ...
    @overload
    def BeginSend(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSend(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: Object) -> Tuple[IAsyncResult, SocketError]: ...
    @overload
    def BeginSendFile(self, fileName: str, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSendFile(self, fileName: str, preBuffer: Set(Byte), postBuffer: Set(Byte), flags: TransmitFileOptions, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def BeginSendTo(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def Bind(self, localEP: EndPoint) -> None: ...
    def CancelConnectAsync(e: SocketAsyncEventArgs) -> None: ...
    @overload
    def Close(self) -> None: ...
    @overload
    def Close(self, timeout: int) -> None: ...
    @overload
    def Connect(self, remoteEP: EndPoint) -> None: ...
    @overload
    def Connect(self, addresses: Set(IPAddress), port: int) -> None: ...
    @overload
    def Connect(self, address: IPAddress, port: int) -> None: ...
    @overload
    def Connect(self, host: str, port: int) -> None: ...
    @overload
    def ConnectAsync(self, remoteEP: EndPoint) -> Task: ...
    @overload
    def ConnectAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def ConnectAsync(self, addresses: Set(IPAddress), port: int) -> Task: ...
    @overload
    def ConnectAsync(self, host: str, port: int) -> Task: ...
    @overload
    def ConnectAsync(self, address: IPAddress, port: int) -> Task: ...
    @overload
    def ConnectAsync(self, remoteEP: EndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(self, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(self, addresses: Set(IPAddress), port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(socketType: SocketType, protocolType: ProtocolType, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def ConnectAsync(self, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    def Disconnect(self, reuseSocket: bool) -> None: ...
    @overload
    def DisconnectAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def DisconnectAsync(self, reuseSocket: bool, cancellationToken: CancellationToken) -> ValueTask: ...
    def Dispose(self) -> None: ...
    def DuplicateAndClose(self, targetProcessId: int) -> SocketInformation: ...
    @overload
    def EndAccept(self, asyncResult: IAsyncResult) -> Socket: ...
    @overload
    def EndAccept(self, asyncResult: IAsyncResult) -> Tuple[Socket, Set(Byte)]: ...
    @overload
    def EndAccept(self, asyncResult: IAsyncResult) -> Tuple[Socket, Set(Byte), int]: ...
    def EndConnect(self, asyncResult: IAsyncResult) -> None: ...
    def EndDisconnect(self, asyncResult: IAsyncResult) -> None: ...
    @overload
    def EndReceive(self, asyncResult: IAsyncResult) -> int: ...
    @overload
    def EndReceive(self, asyncResult: IAsyncResult) -> Tuple[int, SocketError]: ...
    def EndReceiveFrom(self, asyncResult: IAsyncResult, endPoint: EndPoint) -> Tuple[int, EndPoint]: ...
    def EndReceiveMessageFrom(self, asyncResult: IAsyncResult, socketFlags: SocketFlags, endPoint: EndPoint) -> Tuple[int, SocketFlags, EndPoint, IPPacketInformation]: ...
    @overload
    def EndSend(self, asyncResult: IAsyncResult) -> int: ...
    @overload
    def EndSend(self, asyncResult: IAsyncResult) -> Tuple[int, SocketError]: ...
    def EndSendFile(self, asyncResult: IAsyncResult) -> None: ...
    def EndSendTo(self, asyncResult: IAsyncResult) -> int: ...
    @property
    def AddressFamily(self) -> AddressFamily: ...
    @property
    def Available(self) -> int: ...
    @property
    def Blocking(self) -> bool: ...
    @property
    def Connected(self) -> bool: ...
    @property
    def DontFragment(self) -> bool: ...
    @property
    def DualMode(self) -> bool: ...
    @property
    def EnableBroadcast(self) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @property
    def Handle(self) -> IntPtr: ...
    @property
    def IsBound(self) -> bool: ...
    @property
    def LingerState(self) -> LingerOption: ...
    @property
    def LocalEndPoint(self) -> EndPoint: ...
    @property
    def MulticastLoopback(self) -> bool: ...
    @property
    def NoDelay(self) -> bool: ...
    @property
    def OSSupportsIPv4() -> bool: ...
    @property
    def OSSupportsIPv6() -> bool: ...
    @property
    def OSSupportsUnixDomainSockets() -> bool: ...
    @property
    def ProtocolType(self) -> ProtocolType: ...
    @property
    def ReceiveBufferSize(self) -> int: ...
    @property
    def ReceiveTimeout(self) -> int: ...
    @property
    def RemoteEndPoint(self) -> EndPoint: ...
    @property
    def SafeHandle(self) -> SafeSocketHandle: ...
    @property
    def SendBufferSize(self) -> int: ...
    @property
    def SendTimeout(self) -> int: ...
    @property
    def SocketType(self) -> SocketType: ...
    @property
    def SupportsIPv4() -> bool: ...
    @property
    def SupportsIPv6() -> bool: ...
    @property
    def Ttl(self) -> Int16: ...
    @property
    def UseOnlyOverlappedIO(self) -> bool: ...
    def GetRawSocketOption(self, optionLevel: int, optionName: int, optionValue: Span) -> int: ...
    @overload
    def GetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName) -> Object: ...
    @overload
    def GetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: Set(Byte)) -> None: ...
    @overload
    def GetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionLength: int) -> Set(Byte): ...
    @overload
    def IOControl(self, ioControlCode: int, optionInValue: Set(Byte), optionOutValue: Set(Byte)) -> int: ...
    @overload
    def IOControl(self, ioControlCode: IOControlCode, optionInValue: Set(Byte), optionOutValue: Set(Byte)) -> int: ...
    @overload
    def Listen(self) -> None: ...
    @overload
    def Listen(self, backlog: int) -> None: ...
    def Poll(self, microSeconds: int, mode: SelectMode) -> bool: ...
    @overload
    def Receive(self, buffers: List[Byte]) -> int: ...
    @overload
    def Receive(self, buffer: Span) -> int: ...
    @overload
    def Receive(self, buffer: Set(Byte)) -> int: ...
    @overload
    def Receive(self, buffer: Span, socketFlags: SocketFlags) -> int: ...
    @overload
    def Receive(self, buffers: List[Byte], socketFlags: SocketFlags) -> int: ...
    @overload
    def Receive(self, buffer: Set(Byte), socketFlags: SocketFlags) -> int: ...
    @overload
    def Receive(self, buffer: Span, socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def Receive(self, buffers: List[Byte], socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def Receive(self, buffer: Set(Byte), size: int, socketFlags: SocketFlags) -> int: ...
    @overload
    def Receive(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags) -> int: ...
    @overload
    def Receive(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def ReceiveAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def ReceiveAsync(self, buffers: List[Byte], socketFlags: SocketFlags) -> Task: ...
    @overload
    def ReceiveAsync(self, buffer: ArraySegment, socketFlags: SocketFlags) -> Task: ...
    @overload
    def ReceiveAsync(self, buffer: Memory, socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ReceiveFrom(self, buffer: Span, remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFrom(self, buffer: Set(Byte), remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFrom(self, buffer: Set(Byte), socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFrom(self, buffer: Span, socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFrom(self, buffer: Set(Byte), size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFrom(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, EndPoint]: ...
    @overload
    def ReceiveFromAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def ReceiveFromAsync(self, buffer: ArraySegment, socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task: ...
    @overload
    def ReceiveFromAsync(self, buffer: Memory, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ReceiveMessageFrom(self, buffer: Span, socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, SocketFlags, EndPoint, IPPacketInformation]: ...
    @overload
    def ReceiveMessageFrom(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> Tuple[int, SocketFlags, EndPoint, IPPacketInformation]: ...
    @overload
    def ReceiveMessageFromAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: ArraySegment, socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task: ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: Memory, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    def Select(checkRead: IList, checkWrite: IList, checkError: IList, microSeconds: int) -> None: ...
    @overload
    def Send(self, buffers: List[Byte]) -> int: ...
    @overload
    def Send(self, buffer: Set(Byte)) -> int: ...
    @overload
    def Send(self, buffer: ReadOnlySpan) -> int: ...
    @overload
    def Send(self, buffer: Set(Byte), socketFlags: SocketFlags) -> int: ...
    @overload
    def Send(self, buffer: ReadOnlySpan, socketFlags: SocketFlags) -> int: ...
    @overload
    def Send(self, buffers: List[Byte], socketFlags: SocketFlags) -> int: ...
    @overload
    def Send(self, buffer: Set(Byte), size: int, socketFlags: SocketFlags) -> int: ...
    @overload
    def Send(self, buffers: List[Byte], socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def Send(self, buffer: ReadOnlySpan, socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def Send(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags) -> int: ...
    @overload
    def Send(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags) -> Tuple[int, SocketError]: ...
    @overload
    def SendAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def SendAsync(self, buffer: ArraySegment, socketFlags: SocketFlags) -> Task: ...
    @overload
    def SendAsync(self, buffers: List[Byte], socketFlags: SocketFlags) -> Task: ...
    @overload
    def SendAsync(self, buffer: ReadOnlyMemory, socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def SendFile(self, fileName: str) -> None: ...
    @overload
    def SendFile(self, fileName: str, preBuffer: Set(Byte), postBuffer: Set(Byte), flags: TransmitFileOptions) -> None: ...
    @overload
    def SendFile(self, fileName: str, preBuffer: ReadOnlySpan, postBuffer: ReadOnlySpan, flags: TransmitFileOptions) -> None: ...
    @overload
    def SendFileAsync(self, fileName: str, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def SendFileAsync(self, fileName: str, preBuffer: ReadOnlyMemory, postBuffer: ReadOnlyMemory, flags: TransmitFileOptions, cancellationToken: CancellationToken) -> ValueTask: ...
    def SendPacketsAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def SendTo(self, buffer: Set(Byte), remoteEP: EndPoint) -> int: ...
    @overload
    def SendTo(self, buffer: ReadOnlySpan, remoteEP: EndPoint) -> int: ...
    @overload
    def SendTo(self, buffer: Set(Byte), socketFlags: SocketFlags, remoteEP: EndPoint) -> int: ...
    @overload
    def SendTo(self, buffer: ReadOnlySpan, socketFlags: SocketFlags, remoteEP: EndPoint) -> int: ...
    @overload
    def SendTo(self, buffer: Set(Byte), size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> int: ...
    @overload
    def SendTo(self, buffer: Set(Byte), offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> int: ...
    @overload
    def SendToAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    @overload
    def SendToAsync(self, buffer: ArraySegment, socketFlags: SocketFlags, remoteEP: EndPoint) -> Task: ...
    @overload
    def SendToAsync(self, buffer: ReadOnlyMemory, socketFlags: SocketFlags, remoteEP: EndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @Blocking.setter
    def Blocking(self, value: bool) -> None: ...
    @DontFragment.setter
    def DontFragment(self, value: bool) -> None: ...
    @DualMode.setter
    def DualMode(self, value: bool) -> None: ...
    @EnableBroadcast.setter
    def EnableBroadcast(self, value: bool) -> None: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> None: ...
    @LingerState.setter
    def LingerState(self, value: LingerOption) -> None: ...
    @MulticastLoopback.setter
    def MulticastLoopback(self, value: bool) -> None: ...
    @NoDelay.setter
    def NoDelay(self, value: bool) -> None: ...
    @ReceiveBufferSize.setter
    def ReceiveBufferSize(self, value: int) -> None: ...
    @ReceiveTimeout.setter
    def ReceiveTimeout(self, value: int) -> None: ...
    @SendBufferSize.setter
    def SendBufferSize(self, value: int) -> None: ...
    @SendTimeout.setter
    def SendTimeout(self, value: int) -> None: ...
    @Ttl.setter
    def Ttl(self, value: Int16) -> None: ...
    @UseOnlyOverlappedIO.setter
    def UseOnlyOverlappedIO(self, value: bool) -> None: ...
    def SetIPProtectionLevel(self, level: IPProtectionLevel) -> None: ...
    def SetRawSocketOption(self, optionLevel: int, optionName: int, optionValue: ReadOnlySpan) -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: bool) -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: int) -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: Object) -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: Set(Byte)) -> None: ...
    def Shutdown(self, how: SocketShutdown) -> None: ...


class SocketAsyncEventArgs(EventArgs):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, unsafeSuppressExecutionContextFlow: bool): ...
    def add_Completed(self, value: EventHandler) -> None: ...
    def Dispose(self) -> None: ...
    @property
    def AcceptSocket(self) -> Socket: ...
    @property
    def Buffer(self) -> Set(Byte): ...
    @property
    def BufferList(self) -> List[Byte]: ...
    @property
    def BytesTransferred(self) -> int: ...
    @property
    def ConnectByNameError(self) -> Exception: ...
    @property
    def ConnectSocket(self) -> Socket: ...
    @property
    def Count(self) -> int: ...
    @property
    def DisconnectReuseSocket(self) -> bool: ...
    @property
    def LastOperation(self) -> SocketAsyncOperation: ...
    @property
    def MemoryBuffer(self) -> Memory: ...
    @property
    def Offset(self) -> int: ...
    @property
    def ReceiveMessageFromPacketInfo(self) -> IPPacketInformation: ...
    @property
    def RemoteEndPoint(self) -> EndPoint: ...
    @property
    def SendPacketsElements(self) -> Set(SendPacketsElement): ...
    @property
    def SendPacketsFlags(self) -> TransmitFileOptions: ...
    @property
    def SendPacketsSendSize(self) -> int: ...
    @property
    def SocketError(self) -> SocketError: ...
    @property
    def SocketFlags(self) -> SocketFlags: ...
    @property
    def UserToken(self) -> Object: ...
    def remove_Completed(self, value: EventHandler) -> None: ...
    @AcceptSocket.setter
    def AcceptSocket(self, value: Socket) -> None: ...
    @BufferList.setter
    def BufferList(self, value: List[Byte]) -> None: ...
    @DisconnectReuseSocket.setter
    def DisconnectReuseSocket(self, value: bool) -> None: ...
    @RemoteEndPoint.setter
    def RemoteEndPoint(self, value: EndPoint) -> None: ...
    @SendPacketsElements.setter
    def SendPacketsElements(self, value: Set(SendPacketsElement)) -> None: ...
    @SendPacketsFlags.setter
    def SendPacketsFlags(self, value: TransmitFileOptions) -> None: ...
    @SendPacketsSendSize.setter
    def SendPacketsSendSize(self, value: int) -> None: ...
    @SocketError.setter
    def SocketError(self, value: SocketError) -> None: ...
    @SocketFlags.setter
    def SocketFlags(self, value: SocketFlags) -> None: ...
    @UserToken.setter
    def UserToken(self, value: Object) -> None: ...
    @overload
    def SetBuffer(self, buffer: Memory) -> None: ...
    @overload
    def SetBuffer(self, offset: int, count: int) -> None: ...
    @overload
    def SetBuffer(self, buffer: Set(Byte), offset: int, count: int) -> None: ...


class SocketAsyncOperation:
    #None = 0
    Accept = 1
    Connect = 2
    Disconnect = 3
    Receive = 4
    ReceiveFrom = 5
    ReceiveMessageFrom = 6
    Send = 7
    SendPackets = 8
    SendTo = 9


class SocketFlags:
    #None = 0
    OutOfBand = 1
    Peek = 2
    DontRoute = 4
    Truncated = 256
    ControlDataTruncated = 512
    Broadcast = 1024
    Multicast = 2048
    Partial = 32768


class SocketInformation(ValueType):
    @property
    def Options(self) -> SocketInformationOptions: ...
    @property
    def ProtocolInformation(self) -> Set(Byte): ...
    @Options.setter
    def Options(self, value: SocketInformationOptions) -> None: ...
    @ProtocolInformation.setter
    def ProtocolInformation(self, value: Set(Byte)) -> None: ...


class SocketInformationOptions:
    NonBlocking = 1
    Connected = 2
    Listening = 4
    UseOnlyOverlappedIO = 8


class SocketOptionLevel:
    IP = 0
    Tcp = 6
    Udp = 17
    IPv6 = 41
    Socket = 65535


class SocketOptionName:
    IPOptions = 1
    NoChecksum = 1
    NoDelay = 1
    Debug = 1
    HeaderIncluded = 2
    AcceptConnection = 2
    Expedited = 2
    BsdUrgent = 2
    TypeOfService = 3
    TcpKeepAliveTime = 3
    IpTimeToLive = 4
    ReuseAddress = 4
    KeepAlive = 8
    MulticastInterface = 9
    MulticastTimeToLive = 10
    MulticastLoopback = 11
    AddMembership = 12
    DropMembership = 13
    DontFragment = 14
    AddSourceMembership = 15
    TcpKeepAliveRetryCount = 16
    DontRoute = 16
    DropSourceMembership = 16
    BlockSource = 17
    TcpKeepAliveInterval = 17
    UnblockSource = 18
    PacketInformation = 19
    ChecksumCoverage = 20
    HopLimit = 21
    IPProtectionLevel = 23
    IPv6Only = 27
    Broadcast = 32
    UseLoopback = 64
    Linger = 128
    OutOfBandInline = 256
    SendBuffer = 4097
    ReceiveBuffer = 4098
    SendLowWater = 4099
    ReceiveLowWater = 4100
    SendTimeout = 4101
    ReceiveTimeout = 4102
    Error = 4103
    Type = 4104
    ReuseUnicastPort = 12295
    UpdateAcceptContext = 28683
    UpdateConnectContext = 28688
    MaxConnections = 2147483647
    DontLinger = -129
    ExclusiveAddressUse = -5


class SocketReceiveFromResult(ValueType):
    pass


class SocketReceiveMessageFromResult(ValueType):
    pass


class SocketShutdown:
    Receive = 0
    Send = 1
    Both = 2


class SocketTaskExtensions(Object):
    @overload
    def AcceptAsync(socket: Socket) -> Task: ...
    @overload
    def AcceptAsync(socket: Socket, acceptSocket: Socket) -> Task: ...
    @overload
    def ConnectAsync(socket: Socket, remoteEP: EndPoint) -> Task: ...
    @overload
    def ConnectAsync(socket: Socket, remoteEP: EndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(socket: Socket, address: IPAddress, port: int) -> Task: ...
    @overload
    def ConnectAsync(socket: Socket, addresses: Set(IPAddress), port: int) -> Task: ...
    @overload
    def ConnectAsync(socket: Socket, host: str, port: int) -> Task: ...
    @overload
    def ConnectAsync(socket: Socket, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(socket: Socket, addresses: Set(IPAddress), port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(socket: Socket, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ReceiveAsync(socket: Socket, buffers: List[Byte], socketFlags: SocketFlags) -> Task: ...
    @overload
    def ReceiveAsync(socket: Socket, buffer: ArraySegment, socketFlags: SocketFlags) -> Task: ...
    @overload
    def ReceiveAsync(socket: Socket, buffer: Memory, socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask: ...
    def ReceiveFromAsync(socket: Socket, buffer: ArraySegment, socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task: ...
    def ReceiveMessageFromAsync(socket: Socket, buffer: ArraySegment, socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task: ...
    @overload
    def SendAsync(socket: Socket, buffer: ArraySegment, socketFlags: SocketFlags) -> Task: ...
    @overload
    def SendAsync(socket: Socket, buffers: List[Byte], socketFlags: SocketFlags) -> Task: ...
    @overload
    def SendAsync(socket: Socket, buffer: ReadOnlyMemory, socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask: ...
    def SendToAsync(socket: Socket, buffer: ArraySegment, socketFlags: SocketFlags, remoteEP: EndPoint) -> Task: ...


class SocketType:
    Stream = 1
    Dgram = 2
    Raw = 3
    Rdm = 4
    Seqpacket = 5
    Unknown = -1


class TcpClient(Object):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, family: AddressFamily): ...
    @overload
    def __init__(self, localEP: IPEndPoint): ...
    @overload
    def __init__(self, hostname: str, port: int): ...
    @overload
    def BeginConnect(self, addresses: Set(IPAddress), port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, host: str, port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginConnect(self, address: IPAddress, port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def Close(self) -> None: ...
    @overload
    def Connect(self, remoteEP: IPEndPoint) -> None: ...
    @overload
    def Connect(self, hostname: str, port: int) -> None: ...
    @overload
    def Connect(self, address: IPAddress, port: int) -> None: ...
    @overload
    def Connect(self, ipAddresses: Set(IPAddress), port: int) -> None: ...
    @overload
    def ConnectAsync(self, remoteEP: IPEndPoint) -> Task: ...
    @overload
    def ConnectAsync(self, remoteEP: IPEndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(self, address: IPAddress, port: int) -> Task: ...
    @overload
    def ConnectAsync(self, host: str, port: int) -> Task: ...
    @overload
    def ConnectAsync(self, addresses: Set(IPAddress), port: int) -> Task: ...
    @overload
    def ConnectAsync(self, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(self, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ConnectAsync(self, addresses: Set(IPAddress), port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    def Dispose(self) -> None: ...
    def EndConnect(self, asyncResult: IAsyncResult) -> None: ...
    @property
    def Available(self) -> int: ...
    @property
    def Client(self) -> Socket: ...
    @property
    def Connected(self) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @property
    def LingerState(self) -> LingerOption: ...
    @property
    def NoDelay(self) -> bool: ...
    @property
    def ReceiveBufferSize(self) -> int: ...
    @property
    def ReceiveTimeout(self) -> int: ...
    @property
    def SendBufferSize(self) -> int: ...
    @property
    def SendTimeout(self) -> int: ...
    def GetStream(self) -> NetworkStream: ...
    @Client.setter
    def Client(self, value: Socket) -> None: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> None: ...
    @LingerState.setter
    def LingerState(self, value: LingerOption) -> None: ...
    @NoDelay.setter
    def NoDelay(self, value: bool) -> None: ...
    @ReceiveBufferSize.setter
    def ReceiveBufferSize(self, value: int) -> None: ...
    @ReceiveTimeout.setter
    def ReceiveTimeout(self, value: int) -> None: ...
    @SendBufferSize.setter
    def SendBufferSize(self, value: int) -> None: ...
    @SendTimeout.setter
    def SendTimeout(self, value: int) -> None: ...


class TcpListener(Object):
    @overload
    def __init__(self, localEP: IPEndPoint): ...
    @overload
    def __init__(self, port: int): ...
    @overload
    def __init__(self, localaddr: IPAddress, port: int): ...
    def AcceptSocket(self) -> Socket: ...
    @overload
    def AcceptSocketAsync(self) -> Task: ...
    @overload
    def AcceptSocketAsync(self, cancellationToken: CancellationToken) -> ValueTask: ...
    def AcceptTcpClient(self) -> TcpClient: ...
    @overload
    def AcceptTcpClientAsync(self) -> Task: ...
    @overload
    def AcceptTcpClientAsync(self, cancellationToken: CancellationToken) -> ValueTask: ...
    def AllowNatTraversal(self, allowed: bool) -> None: ...
    def BeginAcceptSocket(self, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def BeginAcceptTcpClient(self, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def Create(port: int) -> TcpListener: ...
    def EndAcceptSocket(self, asyncResult: IAsyncResult) -> Socket: ...
    def EndAcceptTcpClient(self, asyncResult: IAsyncResult) -> TcpClient: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @property
    def LocalEndpoint(self) -> EndPoint: ...
    @property
    def Server(self) -> Socket: ...
    def Pending(self) -> bool: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> None: ...
    @overload
    def Start(self) -> None: ...
    @overload
    def Start(self, backlog: int) -> None: ...
    def Stop(self) -> None: ...


class TransmitFileOptions:
    UseDefaultWorkerThread = 0
    Disconnect = 1
    ReuseSocket = 2
    WriteBehind = 4
    UseSystemThread = 16
    UseKernelApc = 32


class UdpClient(Object):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, family: AddressFamily): ...
    @overload
    def __init__(self, port: int): ...
    @overload
    def __init__(self, localEP: IPEndPoint): ...
    @overload
    def __init__(self, port: int, family: AddressFamily): ...
    @overload
    def __init__(self, hostname: str, port: int): ...
    def AllowNatTraversal(self, allowed: bool) -> None: ...
    def BeginReceive(self, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSend(self, datagram: Set(Byte), bytes: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSend(self, datagram: Set(Byte), bytes: int, endPoint: IPEndPoint, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    @overload
    def BeginSend(self, datagram: Set(Byte), bytes: int, hostname: str, port: int, requestCallback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def Close(self) -> None: ...
    @overload
    def Connect(self, endPoint: IPEndPoint) -> None: ...
    @overload
    def Connect(self, addr: IPAddress, port: int) -> None: ...
    @overload
    def Connect(self, hostname: str, port: int) -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def DropMulticastGroup(self, multicastAddr: IPAddress) -> None: ...
    @overload
    def DropMulticastGroup(self, multicastAddr: IPAddress, ifindex: int) -> None: ...
    def EndReceive(self, asyncResult: IAsyncResult, remoteEP: IPEndPoint) -> Tuple[Set(Byte), IPEndPoint]: ...
    def EndSend(self, asyncResult: IAsyncResult) -> int: ...
    @property
    def Available(self) -> int: ...
    @property
    def Client(self) -> Socket: ...
    @property
    def DontFragment(self) -> bool: ...
    @property
    def EnableBroadcast(self) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @property
    def MulticastLoopback(self) -> bool: ...
    @property
    def Ttl(self) -> Int16: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: IPAddress) -> None: ...
    @overload
    def JoinMulticastGroup(self, ifindex: int, multicastAddr: IPAddress) -> None: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: IPAddress, localAddress: IPAddress) -> None: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: IPAddress, timeToLive: int) -> None: ...
    def Receive(self, remoteEP: IPEndPoint) -> Tuple[Set(Byte), IPEndPoint]: ...
    @overload
    def ReceiveAsync(self) -> Task: ...
    @overload
    def ReceiveAsync(self, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def Send(self, datagram: ReadOnlySpan) -> int: ...
    @overload
    def Send(self, dgram: Set(Byte), bytes: int) -> int: ...
    @overload
    def Send(self, datagram: ReadOnlySpan, endPoint: IPEndPoint) -> int: ...
    @overload
    def Send(self, datagram: ReadOnlySpan, hostname: str, port: int) -> int: ...
    @overload
    def Send(self, dgram: Set(Byte), bytes: int, endPoint: IPEndPoint) -> int: ...
    @overload
    def Send(self, dgram: Set(Byte), bytes: int, hostname: str, port: int) -> int: ...
    @overload
    def SendAsync(self, datagram: ReadOnlyMemory, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def SendAsync(self, datagram: Set(Byte), bytes: int) -> Task: ...
    @overload
    def SendAsync(self, datagram: Set(Byte), bytes: int, endPoint: IPEndPoint) -> Task: ...
    @overload
    def SendAsync(self, datagram: ReadOnlyMemory, endPoint: IPEndPoint, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def SendAsync(self, datagram: Set(Byte), bytes: int, hostname: str, port: int) -> Task: ...
    @overload
    def SendAsync(self, datagram: ReadOnlyMemory, hostname: str, port: int, cancellationToken: CancellationToken) -> ValueTask: ...
    @Client.setter
    def Client(self, value: Socket) -> None: ...
    @DontFragment.setter
    def DontFragment(self, value: bool) -> None: ...
    @EnableBroadcast.setter
    def EnableBroadcast(self, value: bool) -> None: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> None: ...
    @MulticastLoopback.setter
    def MulticastLoopback(self, value: bool) -> None: ...
    @Ttl.setter
    def Ttl(self, value: Int16) -> None: ...


class UdpReceiveResult(ValueType):
    def __init__(self, buffer: Set(Byte), remoteEndPoint: IPEndPoint): ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: UdpReceiveResult) -> bool: ...
    @property
    def Buffer(self) -> Set(Byte): ...
    @property
    def RemoteEndPoint(self) -> IPEndPoint: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: UdpReceiveResult, right: UdpReceiveResult) -> bool: ...
    def op_Inequality(left: UdpReceiveResult, right: UdpReceiveResult) -> bool: ...


class UnixDomainSocketEndPoint(EndPoint):
    def __init__(self, path: str): ...
    def Create(self, socketAddress: SocketAddress) -> EndPoint: ...
    @property
    def AddressFamily(self) -> AddressFamily: ...
    def Serialize(self) -> SocketAddress: ...
    def ToString(self) -> str: ...
