from typing import Tuple, Set, Iterable, List


class AsymmetricAlgorithm(Object):
    def Clear(self) -> None: ...
    def Create(algName: str) -> AsymmetricAlgorithm: ...
    def Dispose(self) -> None: ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: ReadOnlySpan, pbeParameters: PbeParameters) -> Set(Byte): ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: ReadOnlySpan, pbeParameters: PbeParameters) -> Set(Byte): ...
    def ExportPkcs8PrivateKey(self) -> Set(Byte): ...
    def ExportSubjectPublicKeyInfo(self) -> Set(Byte): ...
    def FromXmlString(self, xmlString: str) -> None: ...
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @property
    def LegalKeySizes(self) -> Set(KeySizes): ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: ReadOnlySpan, source: ReadOnlySpan) -> Tuple[int]: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: ReadOnlySpan, source: ReadOnlySpan) -> Tuple[int]: ...
    @overload
    def ImportFromEncryptedPem(self, input: ReadOnlySpan, password: ReadOnlySpan) -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: ReadOnlySpan, passwordBytes: ReadOnlySpan) -> None: ...
    def ImportFromPem(self, input: ReadOnlySpan) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan) -> Tuple[int]: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan) -> Tuple[int]: ...
    @KeySize.setter
    def KeySize(self, value: int) -> None: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: ReadOnlySpan, pbeParameters: PbeParameters, destination: Span) -> Tuple[bool, int]: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: ReadOnlySpan, pbeParameters: PbeParameters, destination: Span) -> Tuple[bool, int]: ...
    def TryExportPkcs8PrivateKey(self, destination: Span) -> Tuple[bool, int]: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span) -> Tuple[bool, int]: ...


class CipherMode:
    CBC = 1
    ECB = 2
    OFB = 3
    CFB = 4
    CTS = 5


class CryptographicOperations(Object):
    def FixedTimeEquals(left: ReadOnlySpan, right: ReadOnlySpan) -> bool: ...
    def ZeroMemory(buffer: Span) -> None: ...


class CryptographicUnexpectedOperationException(CryptographicException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, inner: Exception): ...
    @overload
    def __init__(self, format: str, insert: str): ...


class CryptoStream(Stream):
    @overload
    def __init__(self, stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode): ...
    @overload
    def __init__(self, stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: bool): ...
    def BeginRead(self, buffer: Set(Byte), offset: int, count: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Set(Byte), offset: int, count: int, callback: AsyncCallback, state: Object) -> IAsyncResult: ...
    def Clear(self) -> None: ...
    @overload
    def CopyTo(self, destination: Stream, bufferSize: int) -> None: ...
    @overload
    def CopyToAsync(self, destination: Stream, bufferSize: int, cancellationToken: CancellationToken) -> Task: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    @overload
    def FlushAsync(self, cancellationToken: CancellationToken) -> Task: ...
    def FlushFinalBlock(self) -> None: ...
    def FlushFinalBlockAsync(self, cancellationToken: CancellationToken) -> ValueTask: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def HasFlushedFinalBlock(self) -> bool: ...
    @property
    def Length(self) -> Int64: ...
    @property
    def Position(self) -> Int64: ...
    @overload
    def Read(self, buffer: Set(Byte), offset: int, count: int) -> int: ...
    @overload
    def ReadAsync(self, buffer: Memory, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def ReadAsync(self, buffer: Set(Byte), offset: int, count: int, cancellationToken: CancellationToken) -> Task: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: Int64, origin: SeekOrigin) -> Int64: ...
    @Position.setter
    def Position(self, value: Int64) -> None: ...
    def SetLength(self, value: Int64) -> None: ...
    @overload
    def Write(self, buffer: Set(Byte), offset: int, count: int) -> None: ...
    @overload
    def WriteAsync(self, buffer: ReadOnlyMemory, cancellationToken: CancellationToken) -> ValueTask: ...
    @overload
    def WriteAsync(self, buffer: Set(Byte), offset: int, count: int, cancellationToken: CancellationToken) -> Task: ...
    def WriteByte(self, value: Byte) -> None: ...


class CryptoStreamMode:
    Read = 0
    Write = 1


class HashAlgorithm(Object):
    def Clear(self) -> None: ...
    @overload
    def ComputeHash(self, inputStream: Stream) -> Set(Byte): ...
    @overload
    def ComputeHash(self, buffer: Set(Byte)) -> Set(Byte): ...
    @overload
    def ComputeHash(self, buffer: Set(Byte), offset: int, count: int) -> Set(Byte): ...
    def ComputeHashAsync(self, inputStream: Stream, cancellationToken: CancellationToken) -> Task: ...
    def Create(hashName: str) -> HashAlgorithm: ...
    def Dispose(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Set(Byte): ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...
    def TransformBlock(self, inputBuffer: Set(Byte), inputOffset: int, inputCount: int, outputBuffer: Set(Byte), outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: Set(Byte), inputOffset: int, inputCount: int) -> Set(Byte): ...
    def TryComputeHash(self, source: ReadOnlySpan, destination: Span) -> Tuple[bool, int]: ...


class HashAlgorithmName(ValueType):
    def __init__(self, name: str): ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: HashAlgorithmName) -> bool: ...
    def FromOid(oidValue: str) -> HashAlgorithmName: ...
    @property
    def MD5() -> HashAlgorithmName: ...
    @property
    def Name(self) -> str: ...
    @property
    def SHA1() -> HashAlgorithmName: ...
    @property
    def SHA256() -> HashAlgorithmName: ...
    @property
    def SHA384() -> HashAlgorithmName: ...
    @property
    def SHA512() -> HashAlgorithmName: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: HashAlgorithmName, right: HashAlgorithmName) -> bool: ...
    def op_Inequality(left: HashAlgorithmName, right: HashAlgorithmName) -> bool: ...
    def ToString(self) -> str: ...
    def TryFromOid(oidValue: str) -> Tuple[bool, HashAlgorithmName]: ...


class HMAC(KeyedHashAlgorithm):
    def Create(algorithmName: str) -> HMAC: ...
    @property
    def HashName(self) -> str: ...
    @property
    def Key(self) -> Set(Byte): ...
    def Initialize(self) -> None: ...
    @HashName.setter
    def HashName(self, value: str) -> None: ...
    @Key.setter
    def Key(self, value: Set(Byte)) -> None: ...


class ICryptoTransform:
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def TransformBlock(self, inputBuffer: Set(Byte), inputOffset: int, inputCount: int, outputBuffer: Set(Byte), outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: Set(Byte), inputOffset: int, inputCount: int) -> Set(Byte): ...


class KeyedHashAlgorithm(HashAlgorithm):
    def Create(algName: str) -> KeyedHashAlgorithm: ...
    @property
    def Key(self) -> Set(Byte): ...
    @Key.setter
    def Key(self, value: Set(Byte)) -> None: ...


class KeySizes(Object):
    def __init__(self, minSize: int, maxSize: int, skipSize: int): ...
    @property
    def MaxSize(self) -> int: ...
    @property
    def MinSize(self) -> int: ...
    @property
    def SkipSize(self) -> int: ...


class PaddingMode:
    #None = 1
    PKCS7 = 2
    Zeros = 3
    ANSIX923 = 4
    ISO10126 = 5


class PbeEncryptionAlgorithm:
    Unknown = 0
    Aes128Cbc = 1
    Aes192Cbc = 2
    Aes256Cbc = 3
    TripleDes3KeyPkcs12 = 4


class PbeParameters(Object):
    def __init__(self, encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int): ...
    @property
    def EncryptionAlgorithm(self) -> PbeEncryptionAlgorithm: ...
    @property
    def HashAlgorithm(self) -> HashAlgorithmName: ...
    @property
    def IterationCount(self) -> int: ...


class SymmetricAlgorithm(Object):
    def Clear(self) -> None: ...
    def Create(algName: str) -> SymmetricAlgorithm: ...
    @overload
    def CreateDecryptor(self) -> ICryptoTransform: ...
    @overload
    def CreateDecryptor(self, rgbKey: Set(Byte), rgbIV: Set(Byte)) -> ICryptoTransform: ...
    @overload
    def CreateEncryptor(self) -> ICryptoTransform: ...
    @overload
    def CreateEncryptor(self, rgbKey: Set(Byte), rgbIV: Set(Byte)) -> ICryptoTransform: ...
    @overload
    def DecryptCbc(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def DecryptCbc(self, ciphertext: Set(Byte), iv: Set(Byte), paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def DecryptCbc(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> int: ...
    @overload
    def DecryptCfb(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, paddingMode: PaddingMode, feedbackSizeInBits: int) -> Set(Byte): ...
    @overload
    def DecryptCfb(self, ciphertext: Set(Byte), iv: Set(Byte), paddingMode: PaddingMode, feedbackSizeInBits: int) -> Set(Byte): ...
    @overload
    def DecryptCfb(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode, feedbackSizeInBits: int) -> int: ...
    @overload
    def DecryptEcb(self, ciphertext: ReadOnlySpan, paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def DecryptEcb(self, ciphertext: Set(Byte), paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def DecryptEcb(self, ciphertext: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> int: ...
    def Dispose(self) -> None: ...
    @overload
    def EncryptCbc(self, plaintext: Set(Byte), iv: Set(Byte), paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def EncryptCbc(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def EncryptCbc(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> int: ...
    @overload
    def EncryptCfb(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, paddingMode: PaddingMode, feedbackSizeInBits: int) -> Set(Byte): ...
    @overload
    def EncryptCfb(self, plaintext: Set(Byte), iv: Set(Byte), paddingMode: PaddingMode, feedbackSizeInBits: int) -> Set(Byte): ...
    @overload
    def EncryptCfb(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode, feedbackSizeInBits: int) -> int: ...
    @overload
    def EncryptEcb(self, plaintext: ReadOnlySpan, paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def EncryptEcb(self, plaintext: Set(Byte), paddingMode: PaddingMode) -> Set(Byte): ...
    @overload
    def EncryptEcb(self, plaintext: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> int: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @property
    def IV(self) -> Set(Byte): ...
    @property
    def Key(self) -> Set(Byte): ...
    @property
    def KeySize(self) -> int: ...
    @property
    def LegalBlockSizes(self) -> Set(KeySizes): ...
    @property
    def LegalKeySizes(self) -> Set(KeySizes): ...
    @property
    def Mode(self) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    def GetCiphertextLengthCbc(self, plaintextLength: int, paddingMode: PaddingMode) -> int: ...
    def GetCiphertextLengthCfb(self, plaintextLength: int, paddingMode: PaddingMode, feedbackSizeInBits: int) -> int: ...
    def GetCiphertextLengthEcb(self, plaintextLength: int, paddingMode: PaddingMode) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> None: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> None: ...
    @IV.setter
    def IV(self, value: Set(Byte)) -> None: ...
    @Key.setter
    def Key(self, value: Set(Byte)) -> None: ...
    @KeySize.setter
    def KeySize(self, value: int) -> None: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> None: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> None: ...
    def TryDecryptCbc(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> Tuple[bool, int]: ...
    def TryDecryptCfb(self, ciphertext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode, feedbackSizeInBits: int) -> Tuple[bool, int]: ...
    def TryDecryptEcb(self, ciphertext: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> Tuple[bool, int]: ...
    def TryEncryptCbc(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> Tuple[bool, int]: ...
    def TryEncryptCfb(self, plaintext: ReadOnlySpan, iv: ReadOnlySpan, destination: Span, paddingMode: PaddingMode, feedbackSizeInBits: int) -> Tuple[bool, int]: ...
    def TryEncryptEcb(self, plaintext: ReadOnlySpan, destination: Span, paddingMode: PaddingMode) -> Tuple[bool, int]: ...
    def ValidKeySize(self, bitLength: int) -> bool: ...
