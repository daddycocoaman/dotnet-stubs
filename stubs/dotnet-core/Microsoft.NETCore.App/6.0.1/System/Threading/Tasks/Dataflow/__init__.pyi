from typing import Tuple, Set, Iterable, List














class DataflowBlock(Object):
    def AsObservable(source: ISourceBlock) -> IObservable: ...
    def AsObserver(target: ITargetBlock) -> IObserver: ...
    @overload
    def Choose(source1: ISourceBlock, action1: Action, source2: ISourceBlock, action2: Action) -> Task: ...
    @overload
    def Choose(source1: ISourceBlock, action1: Action, source2: ISourceBlock, action2: Action, dataflowBlockOptions: DataflowBlockOptions) -> Task: ...
    @overload
    def Choose(source1: ISourceBlock, action1: Action, source2: ISourceBlock, action2: Action, source3: ISourceBlock, action3: Action) -> Task: ...
    @overload
    def Choose(source1: ISourceBlock, action1: Action, source2: ISourceBlock, action2: Action, source3: ISourceBlock, action3: Action, dataflowBlockOptions: DataflowBlockOptions) -> Task: ...
    def Encapsulate(target: ITargetBlock, source: ISourceBlock) -> IPropagatorBlock: ...
    @overload
    def LinkTo(source: ISourceBlock, target: ITargetBlock) -> IDisposable: ...
    @overload
    def LinkTo(source: ISourceBlock, target: ITargetBlock, predicate: Predicate) -> IDisposable: ...
    @overload
    def LinkTo(source: ISourceBlock, target: ITargetBlock, linkOptions: DataflowLinkOptions, predicate: Predicate) -> IDisposable: ...
    def NullTarget() -> ITargetBlock: ...
    @overload
    def OutputAvailableAsync(source: ISourceBlock) -> Task: ...
    @overload
    def OutputAvailableAsync(source: ISourceBlock, cancellationToken: CancellationToken) -> Task: ...
    def Post(target: ITargetBlock, item: TInput) -> bool: ...
    @overload
    def Receive(source: ISourceBlock) -> TOutput: ...
    @overload
    def Receive(source: ISourceBlock, cancellationToken: CancellationToken) -> TOutput: ...
    @overload
    def Receive(source: ISourceBlock, timeout: TimeSpan) -> TOutput: ...
    @overload
    def Receive(source: ISourceBlock, timeout: TimeSpan, cancellationToken: CancellationToken) -> TOutput: ...
    def ReceiveAllAsync(source: IReceivableSourceBlock, cancellationToken: CancellationToken) -> IAsyncEnumerable: ...
    @overload
    def ReceiveAsync(source: ISourceBlock) -> Task: ...
    @overload
    def ReceiveAsync(source: ISourceBlock, cancellationToken: CancellationToken) -> Task: ...
    @overload
    def ReceiveAsync(source: ISourceBlock, timeout: TimeSpan) -> Task: ...
    @overload
    def ReceiveAsync(source: ISourceBlock, timeout: TimeSpan, cancellationToken: CancellationToken) -> Task: ...
    @overload
    def SendAsync(target: ITargetBlock, item: TInput) -> Task: ...
    @overload
    def SendAsync(target: ITargetBlock, item: TInput, cancellationToken: CancellationToken) -> Task: ...
    def TryReceive(source: IReceivableSourceBlock) -> Tuple[bool, TOutput]: ...


class DataflowBlockOptions(Object):
    def __init__(self): ...
    @property
    def BoundedCapacity(self) -> int: ...
    @property
    def CancellationToken(self) -> CancellationToken: ...
    @property
    def EnsureOrdered(self) -> bool: ...
    @property
    def MaxMessagesPerTask(self) -> int: ...
    @property
    def NameFormat(self) -> str: ...
    @property
    def TaskScheduler(self) -> TaskScheduler: ...
    @BoundedCapacity.setter
    def BoundedCapacity(self, value: int) -> None: ...
    @CancellationToken.setter
    def CancellationToken(self, value: CancellationToken) -> None: ...
    @EnsureOrdered.setter
    def EnsureOrdered(self, value: bool) -> None: ...
    @MaxMessagesPerTask.setter
    def MaxMessagesPerTask(self, value: int) -> None: ...
    @NameFormat.setter
    def NameFormat(self, value: str) -> None: ...
    @TaskScheduler.setter
    def TaskScheduler(self, value: TaskScheduler) -> None: ...


class DataflowLinkOptions(Object):
    def __init__(self): ...
    @property
    def Append(self) -> bool: ...
    @property
    def MaxMessages(self) -> int: ...
    @property
    def PropagateCompletion(self) -> bool: ...
    @Append.setter
    def Append(self, value: bool) -> None: ...
    @MaxMessages.setter
    def MaxMessages(self, value: int) -> None: ...
    @PropagateCompletion.setter
    def PropagateCompletion(self, value: bool) -> None: ...


class DataflowMessageHeader(ValueType):
    def __init__(self, id: Int64): ...
    @overload
    def Equals(self, other: DataflowMessageHeader) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Id(self) -> Int64: ...
    @property
    def IsValid(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(left: DataflowMessageHeader, right: DataflowMessageHeader) -> bool: ...
    def op_Inequality(left: DataflowMessageHeader, right: DataflowMessageHeader) -> bool: ...


class DataflowMessageStatus:
    Accepted = 0
    Declined = 1
    Postponed = 2
    NotAvailable = 3
    DecliningPermanently = 4


class ExecutionDataflowBlockOptions(DataflowBlockOptions):
    def __init__(self): ...
    @property
    def MaxDegreeOfParallelism(self) -> int: ...
    @property
    def SingleProducerConstrained(self) -> bool: ...
    @MaxDegreeOfParallelism.setter
    def MaxDegreeOfParallelism(self, value: int) -> None: ...
    @SingleProducerConstrained.setter
    def SingleProducerConstrained(self, value: bool) -> None: ...


class GroupingDataflowBlockOptions(DataflowBlockOptions):
    def __init__(self): ...
    @property
    def Greedy(self) -> bool: ...
    @property
    def MaxNumberOfGroups(self) -> Int64: ...
    @Greedy.setter
    def Greedy(self, value: bool) -> None: ...
    @MaxNumberOfGroups.setter
    def MaxNumberOfGroups(self, value: Int64) -> None: ...


class IDataflowBlock:
    def Complete(self) -> None: ...
    def Fault(self, exception: Exception) -> None: ...
    @property
    def Completion(self) -> Task: ...


















