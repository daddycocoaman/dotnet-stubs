from typing import Tuple, Set, Iterable, List


class EnumerableExecutor(Object):
    pass




class EnumerableQuery(Object):
    pass




class Queryable(Object):
    @overload
    def Aggregate(source: IQueryable, func: Expression) -> TSource: ...
    @overload
    def Aggregate(source: IQueryable, seed: TAccumulate, func: Expression) -> TAccumulate: ...
    @overload
    def Aggregate(source: IQueryable, seed: TAccumulate, func: Expression, selector: Expression) -> TResult: ...
    def All(source: IQueryable, predicate: Expression) -> bool: ...
    @overload
    def Any(source: IQueryable) -> bool: ...
    @overload
    def Any(source: IQueryable, predicate: Expression) -> bool: ...
    def Append(source: IQueryable, element: TSource) -> IQueryable: ...
    @overload
    def AsQueryable(source: Iterable[TElement]) -> IQueryable: ...
    @overload
    def AsQueryable(source: IEnumerable) -> IQueryable: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> Single: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> Decimal: ...
    @overload
    def Average(source: IQueryable) -> Nullable: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Single: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Average(source: IQueryable, selector: Expression) -> Decimal: ...
    def Cast(source: IQueryable) -> IQueryable: ...
    def Chunk(source: IQueryable, size: int) -> IQueryable: ...
    def Concat(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Contains(source: IQueryable, item: TSource) -> bool: ...
    @overload
    def Contains(source: IQueryable, item: TSource, comparer: IEqualityComparer) -> bool: ...
    @overload
    def Count(source: IQueryable) -> int: ...
    @overload
    def Count(source: IQueryable, predicate: Expression) -> int: ...
    @overload
    def DefaultIfEmpty(source: IQueryable) -> IQueryable: ...
    @overload
    def DefaultIfEmpty(source: IQueryable, defaultValue: TSource) -> IQueryable: ...
    @overload
    def Distinct(source: IQueryable) -> IQueryable: ...
    @overload
    def Distinct(source: IQueryable, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def DistinctBy(source: IQueryable, keySelector: Expression) -> IQueryable: ...
    @overload
    def DistinctBy(source: IQueryable, keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def ElementAt(source: IQueryable, index: Index) -> TSource: ...
    @overload
    def ElementAt(source: IQueryable, index: int) -> TSource: ...
    @overload
    def ElementAtOrDefault(source: IQueryable, index: Index) -> TSource: ...
    @overload
    def ElementAtOrDefault(source: IQueryable, index: int) -> TSource: ...
    @overload
    def Except(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Except(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def ExceptBy(source1: IQueryable, source2: Iterable[TKey], keySelector: Expression) -> IQueryable: ...
    @overload
    def ExceptBy(source1: IQueryable, source2: Iterable[TKey], keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def First(source: IQueryable) -> TSource: ...
    @overload
    def First(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable, defaultValue: TSource) -> TSource: ...
    @overload
    def FirstOrDefault(source: IQueryable, predicate: Expression, defaultValue: TSource) -> TSource: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupBy(source: IQueryable, keySelector: Expression, elementSelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def GroupJoin(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def GroupJoin(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Intersect(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Intersect(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def IntersectBy(source1: IQueryable, source2: Iterable[TKey], keySelector: Expression) -> IQueryable: ...
    @overload
    def IntersectBy(source1: IQueryable, source2: Iterable[TKey], keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Join(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def Join(outer: IQueryable, inner: Iterable[TInner], outerKeySelector: Expression, innerKeySelector: Expression, resultSelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Last(source: IQueryable) -> TSource: ...
    @overload
    def Last(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable, defaultValue: TSource) -> TSource: ...
    @overload
    def LastOrDefault(source: IQueryable, predicate: Expression, defaultValue: TSource) -> TSource: ...
    @overload
    def LongCount(source: IQueryable) -> Int64: ...
    @overload
    def LongCount(source: IQueryable, predicate: Expression) -> Int64: ...
    @overload
    def Max(source: IQueryable) -> TSource: ...
    @overload
    def Max(source: IQueryable, comparer: IComparer) -> TSource: ...
    @overload
    def Max(source: IQueryable, selector: Expression) -> TResult: ...
    @overload
    def MaxBy(source: IQueryable, keySelector: Expression) -> TSource: ...
    @overload
    def MaxBy(source: IQueryable, keySelector: Expression, comparer: IComparer) -> TSource: ...
    @overload
    def Min(source: IQueryable) -> TSource: ...
    @overload
    def Min(source: IQueryable, selector: Expression) -> TResult: ...
    @overload
    def Min(source: IQueryable, comparer: IComparer) -> TSource: ...
    @overload
    def MinBy(source: IQueryable, keySelector: Expression) -> TSource: ...
    @overload
    def MinBy(source: IQueryable, keySelector: Expression, comparer: IComparer) -> TSource: ...
    def OfType(source: IQueryable) -> IQueryable: ...
    @overload
    def OrderBy(source: IQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def OrderBy(source: IQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def OrderByDescending(source: IQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def OrderByDescending(source: IQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    def Prepend(source: IQueryable, element: TSource) -> IQueryable: ...
    def Reverse(source: IQueryable) -> IQueryable: ...
    @overload
    def Select(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def Select(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, selector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, collectionSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def SelectMany(source: IQueryable, collectionSelector: Expression, resultSelector: Expression) -> IQueryable: ...
    @overload
    def SequenceEqual(source1: IQueryable, source2: Iterable[TSource]) -> bool: ...
    @overload
    def SequenceEqual(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> bool: ...
    @overload
    def Single(source: IQueryable) -> TSource: ...
    @overload
    def Single(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable, defaultValue: TSource) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable, predicate: Expression) -> TSource: ...
    @overload
    def SingleOrDefault(source: IQueryable, predicate: Expression, defaultValue: TSource) -> TSource: ...
    def Skip(source: IQueryable, count: int) -> IQueryable: ...
    def SkipLast(source: IQueryable, count: int) -> IQueryable: ...
    @overload
    def SkipWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def SkipWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def Sum(source: IQueryable) -> int: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Int64: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Single: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> float: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable) -> Decimal: ...
    @overload
    def Sum(source: IQueryable) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> int: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Single: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> float: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Decimal: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Nullable: ...
    @overload
    def Sum(source: IQueryable, selector: Expression) -> Int64: ...
    @overload
    def Take(source: IQueryable, range: Range) -> IQueryable: ...
    @overload
    def Take(source: IQueryable, count: int) -> IQueryable: ...
    def TakeLast(source: IQueryable, count: int) -> IQueryable: ...
    @overload
    def TakeWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def TakeWhile(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def ThenBy(source: IOrderedQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def ThenBy(source: IOrderedQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def ThenByDescending(source: IOrderedQueryable, keySelector: Expression) -> IOrderedQueryable: ...
    @overload
    def ThenByDescending(source: IOrderedQueryable, keySelector: Expression, comparer: IComparer) -> IOrderedQueryable: ...
    @overload
    def Union(source1: IQueryable, source2: Iterable[TSource]) -> IQueryable: ...
    @overload
    def Union(source1: IQueryable, source2: Iterable[TSource], comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def UnionBy(source1: IQueryable, source2: Iterable[TSource], keySelector: Expression) -> IQueryable: ...
    @overload
    def UnionBy(source1: IQueryable, source2: Iterable[TSource], keySelector: Expression, comparer: IEqualityComparer) -> IQueryable: ...
    @overload
    def Where(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def Where(source: IQueryable, predicate: Expression) -> IQueryable: ...
    @overload
    def Zip(source1: IQueryable, source2: Iterable[TSecond]) -> IQueryable: ...
    @overload
    def Zip(source1: IQueryable, source2: Iterable[TSecond], resultSelector: Expression) -> IQueryable: ...
    @overload
    def Zip(source1: IQueryable, source2: Iterable[TSecond], source3: Iterable[TThird]) -> IQueryable: ...
